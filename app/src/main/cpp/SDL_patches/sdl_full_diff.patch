warning: in the working copy of 'sdl_original/VisualC-WinRT/SDL-UWP.vcxproj.filters', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'app/src/main/cpp/SDL/android-project/app/src/main/java/org/libsdl/app/SDLAudioManager.java', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/build-scripts/windows-buildbot-zipper.bat', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'app/src/main/cpp/SDL/src/video/android/SDL_androidvulkan.c', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/shallow', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/packed-refs', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/logs/HEAD', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/info/exclude', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/update.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/sendemail-validate.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/push-to-checkout.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/prepare-commit-msg.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-receive.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-rebase.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-push.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-merge-commit.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-commit.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-applypatch.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/post-update.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/fsmonitor-watchman.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/commit-msg.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/applypatch-msg.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/description', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/config', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/HEAD', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/fsmonitor-watchman.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-commit.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-push.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-rebase.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/prepare-commit-msg.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/push-to-checkout.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/sendemail-validate.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/update.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/HEAD', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/config', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/description', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/applypatch-msg.sample', LF will be replaced by CRLF the next time Git touches it
diff --git a/sdl_original/.git/HEAD b/sdl_original/.git/HEAD
deleted file mode 100644
index e8ffb86..0000000
--- a/sdl_original/.git/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-5adbf3765a57dc5931c2a3137390bfee2370c945
diff --git a/sdl_original/.git/config b/sdl_original/.git/config
deleted file mode 100644
index e370ff0..0000000
--- a/sdl_original/.git/config
+++ /dev/null
@@ -1,10 +0,0 @@
-[core]
-	repositoryformatversion = 0
-	filemode = false
-	bare = false
-	logallrefupdates = true
-	symlinks = false
-	ignorecase = true
-[remote "origin"]
-	url = https://github.com/libsdl-org/SDL.git
-	fetch = +refs/tags/release-2.30.1:refs/tags/release-2.30.1
diff --git a/sdl_original/.git/description b/sdl_original/.git/description
deleted file mode 100644
index 498b267..0000000
--- a/sdl_original/.git/description
+++ /dev/null
@@ -1 +0,0 @@
-Unnamed repository; edit this file 'description' to name the repository.
diff --git a/sdl_original/.git/hooks/applypatch-msg.sample b/sdl_original/.git/hooks/applypatch-msg.sample
deleted file mode 100644
index a5d7b84..0000000
--- a/sdl_original/.git/hooks/applypatch-msg.sample
+++ /dev/null
@@ -1,15 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message taken by
-# applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.  The hook is
-# allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "applypatch-msg".
-
-. git-sh-setup
-commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
-test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
-:
diff --git a/sdl_original/.git/hooks/commit-msg.sample b/sdl_original/.git/hooks/commit-msg.sample
deleted file mode 100644
index b58d118..0000000
--- a/sdl_original/.git/hooks/commit-msg.sample
+++ /dev/null
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to check the commit log message.
-# Called by "git commit" with one argument, the name of the file
-# that has the commit message.  The hook should exit with non-zero
-# status after issuing an appropriate message if it wants to stop the
-# commit.  The hook is allowed to edit the commit message file.
-#
-# To enable this hook, rename this file to "commit-msg".
-
-# Uncomment the below to add a Signed-off-by line to the message.
-# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
-# hook is more suited to it.
-#
-# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
-
-# This example catches duplicate Signed-off-by lines.
-
-test "" = "$(grep '^Signed-off-by: ' "$1" |
-	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
-	echo >&2 Duplicate Signed-off-by lines.
-	exit 1
-}
diff --git a/sdl_original/.git/hooks/fsmonitor-watchman.sample b/sdl_original/.git/hooks/fsmonitor-watchman.sample
deleted file mode 100644
index 23e856f..0000000
--- a/sdl_original/.git/hooks/fsmonitor-watchman.sample
+++ /dev/null
@@ -1,174 +0,0 @@
-#!/usr/bin/perl
-
-use strict;
-use warnings;
-use IPC::Open2;
-
-# An example hook script to integrate Watchman
-# (https://facebook.github.io/watchman/) with git to speed up detecting
-# new and modified files.
-#
-# The hook is passed a version (currently 2) and last update token
-# formatted as a string and outputs to stdout a new update token and
-# all files that have been modified since the update token. Paths must
-# be relative to the root of the working tree and separated by a single NUL.
-#
-# To enable this hook, rename this file to "query-watchman" and set
-# 'git config core.fsmonitor .git/hooks/query-watchman'
-#
-my ($version, $last_update_token) = @ARGV;
-
-# Uncomment for debugging
-# print STDERR "$0 $version $last_update_token\n";
-
-# Check the hook interface version
-if ($version ne 2) {
-	die "Unsupported query-fsmonitor hook version '$version'.\n" .
-	    "Falling back to scanning...\n";
-}
-
-my $git_work_tree = get_working_dir();
-
-my $retry = 1;
-
-my $json_pkg;
-eval {
-	require JSON::XS;
-	$json_pkg = "JSON::XS";
warning: in the working copy of 'sdl_original/.git/hooks/commit-msg.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/fsmonitor-watchman.sample', LF will be replaced by CRLF the next time Git touches it
-	1;
-} or do {
-	require JSON::PP;
-	$json_pkg = "JSON::PP";
-};
-
-launch_watchman();
-
-sub launch_watchman {
-	my $o = watchman_query();
-	if (is_work_tree_watched($o)) {
-		output_result($o->{clock}, @{$o->{files}});
-	}
-}
-
-sub output_result {
-	my ($clockid, @files) = @_;
-
-	# Uncomment for debugging watchman output
-	# open (my $fh, ">", ".git/watchman-output.out");
-	# binmode $fh, ":utf8";
-	# print $fh "$clockid\n@files\n";
-	# close $fh;
-
-	binmode STDOUT, ":utf8";
-	print $clockid;
-	print "\0";
-	local $, = "\0";
-	print @files;
-}
-
-sub watchman_clock {
-	my $response = qx/watchman clock "$git_work_tree"/;
-	die "Failed to get clock id on '$git_work_tree'.\n" .
-		"Falling back to scanning...\n" if $? != 0;
-
-	return $json_pkg->new->utf8->decode($response);
-}
-
-sub watchman_query {
-	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
-	or die "open2() failed: $!\n" .
-	"Falling back to scanning...\n";
-
-	# In the query expression below we're asking for names of files that
-	# changed since $last_update_token but not from the .git folder.
-	#
-	# To accomplish this, we're using the "since" generator to use the
-	# recency index to select candidate nodes and "fields" to limit the
-	# output to file names only. Then we're using the "expression" term to
-	# further constrain the results.
-	my $last_update_line = "";
-	if (substr($last_update_token, 0, 1) eq "c") {
-		$last_update_token = "\"$last_update_token\"";
-		$last_update_line = qq[\n"since": $last_update_token,];
-	}
-	my $query = <<"	END";
-		["query", "$git_work_tree", {$last_update_line
-			"fields": ["name"],
-			"expression": ["not", ["dirname", ".git"]]
-		}]
-	END
-
-	# Uncomment for debugging the watchman query
-	# open (my $fh, ">", ".git/watchman-query.json");
-	# print $fh $query;
-	# close $fh;
-
-	print CHLD_IN $query;
-	close CHLD_IN;
-	my $response = do {local $/; <CHLD_OUT>};
-
-	# Uncomment for debugging the watch response
-	# open ($fh, ">", ".git/watchman-response.json");
-	# print $fh $response;
-	# close $fh;
-
-	die "Watchman: command returned no output.\n" .
-	"Falling back to scanning...\n" if $response eq "";
-	die "Watchman: command returned invalid output: $response\n" .
-	"Falling back to scanning...\n" unless $response =~ /^\{/;
-
-	return $json_pkg->new->utf8->decode($response);
-}
-
-sub is_work_tree_watched {
-	my ($output) = @_;
-	my $error = $output->{error};
-	if ($retry > 0 and $error and $error =~ m/unable to resolve root .* directory (.*) is not watched/) {
-		$retry--;
-		my $response = qx/watchman watch "$git_work_tree"/;
-		die "Failed to make watchman watch '$git_work_tree'.\n" .
-		    "Falling back to scanning...\n" if $? != 0;
-		$output = $json_pkg->new->utf8->decode($response);
-		$error = $output->{error};
-		die "Watchman: $error.\n" .
-		"Falling back to scanning...\n" if $error;
-
-		# Uncomment for debugging watchman output
-		# open (my $fh, ">", ".git/watchman-output.out");
-		# close $fh;
-
-		# Watchman will always return all files on the first query so
-		# return the fast "everything is dirty" flag to git and do the
-		# Watchman query just to get it over with now so we won't pay
-		# the cost in git to look up each individual file.
-		my $o = watchman_clock();
-		$error = $output->{error};
-
-		die "Watchman: $error.\n" .
-		"Falling back to scanning...\n" if $error;
-
-		output_result($o->{clock}, ("/"));
-		$last_update_token = $o->{clock};
-
-		eval { launch_watchman() };
-		return 0;
-	}
-
-	die "Watchman: $error.\n" .
-	"Falling back to scanning...\n" if $error;
-
-	return 1;
-}
-
-sub get_working_dir {
-	my $working_dir;
-	if ($^O =~ 'msys' || $^O =~ 'cygwin') {
-		$working_dir = Win32::GetCwd();
-		$working_dir =~ tr/\\/\//;
-	} else {
-		require Cwd;
-		$working_dir = Cwd::cwd();
-	}
-
-	return $working_dir;
-}
diff --git a/sdl_original/.git/hooks/post-update.sample b/sdl_original/.git/hooks/post-update.sample
deleted file mode 100644
index ec17ec1..0000000
--- a/sdl_original/.git/hooks/post-update.sample
+++ /dev/null
@@ -1,8 +0,0 @@
-#!/bin/sh
-#
warning: in the working copy of 'sdl_original/.git/hooks/post-update.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-applypatch.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-commit.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-merge-commit.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/pre-push.sample', LF will be replaced by CRLF the next time Git touches it
-# An example hook script to prepare a packed repository for use over
-# dumb transports.
-#
-# To enable this hook, rename this file to "post-update".
-
-exec git update-server-info
diff --git a/sdl_original/.git/hooks/pre-applypatch.sample b/sdl_original/.git/hooks/pre-applypatch.sample
deleted file mode 100644
index 4142082..0000000
--- a/sdl_original/.git/hooks/pre-applypatch.sample
+++ /dev/null
@@ -1,14 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed
-# by applypatch from an e-mail message.
-#
-# The hook should exit with non-zero status after issuing an
-# appropriate message if it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-applypatch".
-
-. git-sh-setup
-precommit="$(git rev-parse --git-path hooks/pre-commit)"
-test -x "$precommit" && exec "$precommit" ${1+"$@"}
-:
diff --git a/sdl_original/.git/hooks/pre-commit.sample b/sdl_original/.git/hooks/pre-commit.sample
deleted file mode 100644
index 29ed5ee..0000000
--- a/sdl_original/.git/hooks/pre-commit.sample
+++ /dev/null
@@ -1,49 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git commit" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message if
-# it wants to stop the commit.
-#
-# To enable this hook, rename this file to "pre-commit".
-
-if git rev-parse --verify HEAD >/dev/null 2>&1
-then
-	against=HEAD
-else
-	# Initial commit: diff against an empty tree object
-	against=$(git hash-object -t tree /dev/null)
-fi
-
-# If you want to allow non-ASCII filenames set this variable to true.
-allownonascii=$(git config --type=bool hooks.allownonascii)
-
-# Redirect output to stderr.
-exec 1>&2
-
-# Cross platform projects tend to avoid non-ASCII filenames; prevent
-# them from being added to the repository. We exploit the fact that the
-# printable range starts at the space character and ends with tilde.
-if [ "$allownonascii" != "true" ] &&
-	# Note that the use of brackets around a tr range is ok here, (it's
-	# even required, for portability to Solaris 10's /usr/bin/tr), since
-	# the square bracket bytes happen to fall in the designated range.
-	test $(git diff-index --cached --name-only --diff-filter=A -z $against |
-	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
-then
-	cat <<\EOF
-Error: Attempt to add a non-ASCII file name.
-
-This can cause problems if you want to work with people on other platforms.
-
-To be portable it is advisable to rename the file.
-
-If you know what you are doing you can disable this check using:
-
-  git config hooks.allownonascii true
-EOF
-	exit 1
-fi
-
-# If there are whitespace errors, print the offending file names and fail.
-exec git diff-index --check --cached $against --
diff --git a/sdl_original/.git/hooks/pre-merge-commit.sample b/sdl_original/.git/hooks/pre-merge-commit.sample
deleted file mode 100644
index 399eab1..0000000
--- a/sdl_original/.git/hooks/pre-merge-commit.sample
+++ /dev/null
@@ -1,13 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to verify what is about to be committed.
-# Called by "git merge" with no arguments.  The hook should
-# exit with non-zero status after issuing an appropriate message to
-# stderr if it wants to stop the merge commit.
-#
-# To enable this hook, rename this file to "pre-merge-commit".
-
-. git-sh-setup
-test -x "$GIT_DIR/hooks/pre-commit" &&
-        exec "$GIT_DIR/hooks/pre-commit"
-:
diff --git a/sdl_original/.git/hooks/pre-push.sample b/sdl_original/.git/hooks/pre-push.sample
deleted file mode 100644
index 4ce688d..0000000
--- a/sdl_original/.git/hooks/pre-push.sample
+++ /dev/null
@@ -1,53 +0,0 @@
-#!/bin/sh
-
-# An example hook script to verify what is about to be pushed.  Called by "git
-# push" after it has checked the remote status, but before anything has been
-# pushed.  If this script exits with a non-zero status nothing will be pushed.
-#
-# This hook is called with the following parameters:
-#
-# $1 -- Name of the remote to which the push is being done
-# $2 -- URL to which the push is being done
-#
warning: in the working copy of 'sdl_original/.git/hooks/pre-rebase.sample', LF will be replaced by CRLF the next time Git touches it
-# If pushing without using a named remote those arguments will be equal.
-#
-# Information about the commits which are being pushed is supplied as lines to
-# the standard input in the form:
-#
-#   <local ref> <local oid> <remote ref> <remote oid>
-#
-# This sample shows how to prevent push of commits where the log message starts
-# with "WIP" (work in progress).
-
-remote="$1"
-url="$2"
-
-zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
-
-while read local_ref local_oid remote_ref remote_oid
-do
-	if test "$local_oid" = "$zero"
-	then
-		# Handle delete
-		:
-	else
-		if test "$remote_oid" = "$zero"
-		then
-			# New branch, examine all commits
-			range="$local_oid"
-		else
-			# Update to existing branch, examine new commits
-			range="$remote_oid..$local_oid"
-		fi
-
-		# Check for WIP commit
-		commit=$(git rev-list -n 1 --grep '^WIP' "$range")
-		if test -n "$commit"
-		then
-			echo >&2 "Found WIP commit in $local_ref, not pushing"
-			exit 1
-		fi
-	fi
-done
-
-exit 0
diff --git a/sdl_original/.git/hooks/pre-rebase.sample b/sdl_original/.git/hooks/pre-rebase.sample
deleted file mode 100644
index 6cbef5c..0000000
--- a/sdl_original/.git/hooks/pre-rebase.sample
+++ /dev/null
@@ -1,169 +0,0 @@
-#!/bin/sh
-#
-# Copyright (c) 2006, 2008 Junio C Hamano
-#
-# The "pre-rebase" hook is run just before "git rebase" starts doing
-# its job, and can prevent the command from running by exiting with
-# non-zero status.
-#
-# The hook is called with the following parameters:
-#
-# $1 -- the upstream the series was forked from.
-# $2 -- the branch being rebased (or empty when rebasing the current branch).
-#
-# This sample shows how to prevent topic branches that are already
-# merged to 'next' branch from getting rebased, because allowing it
-# would result in rebasing already published history.
-
-publish=next
-basebranch="$1"
-if test "$#" = 2
-then
-	topic="refs/heads/$2"
-else
-	topic=`git symbolic-ref HEAD` ||
-	exit 0 ;# we do not interrupt rebasing detached HEAD
-fi
-
-case "$topic" in
-refs/heads/??/*)
-	;;
-*)
-	exit 0 ;# we do not interrupt others.
-	;;
-esac
-
-# Now we are dealing with a topic branch being rebased
-# on top of master.  Is it OK to rebase it?
-
-# Does the topic really exist?
-git show-ref -q "$topic" || {
-	echo >&2 "No such branch $topic"
-	exit 1
-}
-
-# Is topic fully merged to master?
-not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
-if test -z "$not_in_master"
-then
-	echo >&2 "$topic is fully merged to master; better remove it."
-	exit 1 ;# we could allow it, but there is no point.
-fi
-
-# Is topic ever merged to next?  If so you should not be rebasing it.
-only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
-only_next_2=`git rev-list ^master           ${publish} | sort`
-if test "$only_next_1" = "$only_next_2"
-then
-	not_in_topic=`git rev-list "^$topic" master`
-	if test -z "$not_in_topic"
-	then
-		echo >&2 "$topic is already up to date with master"
-		exit 1 ;# we could allow it, but there is no point.
-	else
-		exit 0
-	fi
-else
-	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
-	/usr/bin/perl -e '
-		my $topic = $ARGV[0];
-		my $msg = "* $topic has commits already merged to public branch:\n";
-		my (%not_in_next) = map {
-			/^([0-9a-f]+) /;
-			($1 => 1);
-		} split(/\n/, $ARGV[1]);
-		for my $elem (map {
-				/^([0-9a-f]+) (.*)$/;
-				[$1 => $2];
-			} split(/\n/, $ARGV[2])) {
-			if (!exists $not_in_next{$elem->[0]}) {
-				if ($msg) {
-					print STDERR $msg;
-					undef $msg;
-				}
-				print STDERR " $elem->[1]\n";
-			}
-		}
-	' "$topic" "$not_in_next" "$not_in_master"
-	exit 1
-fi
-
-<<\DOC_END
-
-This sample hook safeguards topic branches that have been
-published from being rewound.
-
-The workflow assumed here is:
-
- * Once a topic branch forks from "master", "master" is never
-   merged into it again (either directly or indirectly).
-
- * Once a topic branch is fully cooked and merged into "master",
-   it is deleted.  If you need to build on top of it to correct
-   earlier mistakes, a new topic branch is created by forking at
warning: in the working copy of 'sdl_original/.git/hooks/pre-receive.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/prepare-commit-msg.sample', LF will be replaced by CRLF the next time Git touches it
-   the tip of the "master".  This is not strictly necessary, but
-   it makes it easier to keep your history simple.
-
- * Whenever you need to test or publish your changes to topic
-   branches, merge them into "next" branch.
-
-The script, being an example, hardcodes the publish branch name
-to be "next", but it is trivial to make it configurable via
-$GIT_DIR/config mechanism.
-
-With this workflow, you would want to know:
-
-(1) ... if a topic branch has ever been merged to "next".  Young
-    topic branches can have stupid mistakes you would rather
-    clean up before publishing, and things that have not been
-    merged into other branches can be easily rebased without
-    affecting other people.  But once it is published, you would
-    not want to rewind it.
-
-(2) ... if a topic branch has been fully merged to "master".
-    Then you can delete it.  More importantly, you should not
-    build on top of it -- other people may already want to
-    change things related to the topic as patches against your
-    "master", so if you need further changes, it is better to
-    fork the topic (perhaps with the same name) afresh from the
-    tip of "master".
-
-Let's look at this example:
-
-		   o---o---o---o---o---o---o---o---o---o "next"
-		  /       /           /           /
-		 /   a---a---b A     /           /
-		/   /               /           /
-	       /   /   c---c---c---c B         /
-	      /   /   /             \         /
-	     /   /   /   b---b C     \       /
-	    /   /   /   /             \     /
-    ---o---o---o---o---o---o---o---o---o---o---o "master"
-
-
-A, B and C are topic branches.
-
- * A has one fix since it was merged up to "next".
-
- * B has finished.  It has been fully merged up to "master" and "next",
-   and is ready to be deleted.
-
- * C has not merged to "next" at all.
-
-We would want to allow C to be rebased, refuse A, and encourage
-B to be deleted.
-
-To compute (1):
-
-	git rev-list ^master ^topic next
-	git rev-list ^master        next
-
-	if these match, topic has not merged in next at all.
-
-To compute (2):
-
-	git rev-list master..topic
-
-	if this is empty, it is fully merged to "master".
-
-DOC_END
diff --git a/sdl_original/.git/hooks/pre-receive.sample b/sdl_original/.git/hooks/pre-receive.sample
deleted file mode 100644
index a1fd29e..0000000
--- a/sdl_original/.git/hooks/pre-receive.sample
+++ /dev/null
@@ -1,24 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to make use of push options.
-# The example simply echoes all push options that start with 'echoback='
-# and rejects all pushes when the "reject" push option is used.
-#
-# To enable this hook, rename this file to "pre-receive".
-
-if test -n "$GIT_PUSH_OPTION_COUNT"
-then
-	i=0
-	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
-	do
-		eval "value=\$GIT_PUSH_OPTION_$i"
-		case "$value" in
-		echoback=*)
-			echo "echo from the pre-receive-hook: ${value#*=}" >&2
-			;;
-		reject)
-			exit 1
-		esac
-		i=$((i + 1))
-	done
-fi
diff --git a/sdl_original/.git/hooks/prepare-commit-msg.sample b/sdl_original/.git/hooks/prepare-commit-msg.sample
deleted file mode 100644
index 10fa14c..0000000
--- a/sdl_original/.git/hooks/prepare-commit-msg.sample
+++ /dev/null
@@ -1,42 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to prepare the commit log message.
-# Called by "git commit" with the name of the file that has the
-# commit message, followed by the description of the commit
-# message's source.  The hook's purpose is to edit the commit
-# message file.  If the hook fails with a non-zero status,
-# the commit is aborted.
-#
-# To enable this hook, rename this file to "prepare-commit-msg".
-
-# This hook includes three examples. The first one removes the
-# "# Please enter the commit message..." help message.
-#
-# The second includes the output of "git diff --name-status -r"
-# into the message, just before the "git status" output.  It is
-# commented because it doesn't cope with --amend or with squashed
-# commits.
-#
-# The third example adds a Signed-off-by line to the message, that can
warning: in the working copy of 'sdl_original/.git/hooks/push-to-checkout.sample', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/hooks/sendemail-validate.sample', LF will be replaced by CRLF the next time Git touches it
-# still be edited.  This is rarely a good idea.
-
-COMMIT_MSG_FILE=$1
-COMMIT_SOURCE=$2
-SHA1=$3
-
-/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
-
-# case "$COMMIT_SOURCE,$SHA1" in
-#  ,|template,)
-#    /usr/bin/perl -i.bak -pe '
-#       print "\n" . `git diff --cached --name-status -r`
-# 	 if /^#/ && $first++ == 0' "$COMMIT_MSG_FILE" ;;
-#  *) ;;
-# esac
-
-# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
-# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
-# if test -z "$COMMIT_SOURCE"
-# then
-#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
-# fi
diff --git a/sdl_original/.git/hooks/push-to-checkout.sample b/sdl_original/.git/hooks/push-to-checkout.sample
deleted file mode 100644
index af5a0c0..0000000
--- a/sdl_original/.git/hooks/push-to-checkout.sample
+++ /dev/null
@@ -1,78 +0,0 @@
-#!/bin/sh
-
-# An example hook script to update a checked-out tree on a git push.
-#
-# This hook is invoked by git-receive-pack(1) when it reacts to git
-# push and updates reference(s) in its repository, and when the push
-# tries to update the branch that is currently checked out and the
-# receive.denyCurrentBranch configuration variable is set to
-# updateInstead.
-#
-# By default, such a push is refused if the working tree and the index
-# of the remote repository has any difference from the currently
-# checked out commit; when both the working tree and the index match
-# the current commit, they are updated to match the newly pushed tip
-# of the branch. This hook is to be used to override the default
-# behaviour; however the code below reimplements the default behaviour
-# as a starting point for convenient modification.
-#
-# The hook receives the commit with which the tip of the current
-# branch is going to be updated:
-commit=$1
-
-# It can exit with a non-zero status to refuse the push (when it does
-# so, it must not modify the index or the working tree).
-die () {
-	echo >&2 "$*"
-	exit 1
-}
-
-# Or it can make any necessary changes to the working tree and to the
-# index to bring them to the desired state when the tip of the current
-# branch is updated to the new commit, and exit with a zero status.
-#
-# For example, the hook can simply run git read-tree -u -m HEAD "$1"
-# in order to emulate git fetch that is run in the reverse direction
-# with git push, as the two-tree form of git read-tree -u -m is
-# essentially the same as git switch or git checkout that switches
-# branches while keeping the local changes in the working tree that do
-# not interfere with the difference between the branches.
-
-# The below is a more-or-less exact translation to shell of the C code
-# for the default behaviour for git's push-to-checkout hook defined in
-# the push_to_deploy() function in builtin/receive-pack.c.
-#
-# Note that the hook will be executed from the repository directory,
-# not from the working tree, so if you want to perform operations on
-# the working tree, you will have to adapt your code accordingly, e.g.
-# by adding "cd .." or using relative paths.
-
-if ! git update-index -q --ignore-submodules --refresh
-then
-	die "Up-to-date check failed"
-fi
-
-if ! git diff-files --quiet --ignore-submodules --
-then
-	die "Working directory has unstaged changes"
-fi
-
-# This is a rough translation of:
-#
-#   head_has_history() ? "HEAD" : EMPTY_TREE_SHA1_HEX
-if git cat-file -e HEAD 2>/dev/null
-then
-	head=HEAD
-else
-	head=$(git hash-object -t tree --stdin </dev/null)
-fi
-
-if ! git diff-index --quiet --cached --ignore-submodules $head --
-then
-	die "Working directory has staged changes"
-fi
-
-if ! git read-tree -u -m "$commit"
-then
-	die "Could not update working tree to new HEAD"
-fi
diff --git a/sdl_original/.git/hooks/sendemail-validate.sample b/sdl_original/.git/hooks/sendemail-validate.sample
deleted file mode 100644
index 640bcf8..0000000
--- a/sdl_original/.git/hooks/sendemail-validate.sample
+++ /dev/null
@@ -1,77 +0,0 @@
-#!/bin/sh
-
warning: in the working copy of 'sdl_original/.git/hooks/update.sample', LF will be replaced by CRLF the next time Git touches it
-# An example hook script to validate a patch (and/or patch series) before
-# sending it via email.
-#
-# The hook should exit with non-zero status after issuing an appropriate
-# message if it wants to prevent the email(s) from being sent.
-#
-# To enable this hook, rename this file to "sendemail-validate".
-#
-# By default, it will only check that the patch(es) can be applied on top of
-# the default upstream branch without conflicts in a secondary worktree. After
-# validation (successful or not) of the last patch of a series, the worktree
-# will be deleted.
-#
-# The following config variables can be set to change the default remote and
-# remote ref that are used to apply the patches against:
-#
-#   sendemail.validateRemote (default: origin)
-#   sendemail.validateRemoteRef (default: HEAD)
-#
-# Replace the TODO placeholders with appropriate checks according to your
-# needs.
-
-validate_cover_letter () {
-	file="$1"
-	# TODO: Replace with appropriate checks (e.g. spell checking).
-	true
-}
-
-validate_patch () {
-	file="$1"
-	# Ensure that the patch applies without conflicts.
-	git am -3 "$file" || return
-	# TODO: Replace with appropriate checks for this patch
-	# (e.g. checkpatch.pl).
-	true
-}
-
-validate_series () {
-	# TODO: Replace with appropriate checks for the whole series
-	# (e.g. quick build, coding style checks, etc.).
-	true
-}
-
-# main -------------------------------------------------------------------------
-
-if test "$GIT_SENDEMAIL_FILE_COUNTER" = 1
-then
-	remote=$(git config --default origin --get sendemail.validateRemote) &&
-	ref=$(git config --default HEAD --get sendemail.validateRemoteRef) &&
-	worktree=$(mktemp --tmpdir -d sendemail-validate.XXXXXXX) &&
-	git worktree add -fd --checkout "$worktree" "refs/remotes/$remote/$ref" &&
-	git config --replace-all sendemail.validateWorktree "$worktree"
-else
-	worktree=$(git config --get sendemail.validateWorktree)
-fi || {
-	echo "sendemail-validate: error: failed to prepare worktree" >&2
-	exit 1
-}
-
-unset GIT_DIR GIT_WORK_TREE
-cd "$worktree" &&
-
-if grep -q "^diff --git " "$1"
-then
-	validate_patch "$1"
-else
-	validate_cover_letter "$1"
-fi &&
-
-if test "$GIT_SENDEMAIL_FILE_COUNTER" = "$GIT_SENDEMAIL_FILE_TOTAL"
-then
-	git config --unset-all sendemail.validateWorktree &&
-	trap 'git worktree remove -ff "$worktree"' EXIT &&
-	validate_series
-fi
diff --git a/sdl_original/.git/hooks/update.sample b/sdl_original/.git/hooks/update.sample
deleted file mode 100644
index c4d426b..0000000
--- a/sdl_original/.git/hooks/update.sample
+++ /dev/null
@@ -1,128 +0,0 @@
-#!/bin/sh
-#
-# An example hook script to block unannotated tags from entering.
-# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
-#
-# To enable this hook, rename this file to "update".
-#
-# Config
-# ------
-# hooks.allowunannotated
-#   This boolean sets whether unannotated tags will be allowed into the
-#   repository.  By default they won't be.
-# hooks.allowdeletetag
-#   This boolean sets whether deleting tags will be allowed in the
-#   repository.  By default they won't be.
-# hooks.allowmodifytag
-#   This boolean sets whether a tag may be modified after creation. By default
-#   it won't be.
-# hooks.allowdeletebranch
-#   This boolean sets whether deleting branches will be allowed in the
-#   repository.  By default they won't be.
-# hooks.denycreatebranch
-#   This boolean sets whether remotely creating branches will be denied
-#   in the repository.  By default this is allowed.
-#
-
-# --- Command line
-refname="$1"
-oldrev="$2"
-newrev="$3"
-
-# --- Safety check
-if [ -z "$GIT_DIR" ]; then
-	echo "Don't run this script from the command line." >&2
-	echo " (if you want, you could supply GIT_DIR then run" >&2
-	echo "  $0 <ref> <oldrev> <newrev>)" >&2
-	exit 1
-fi
-
-if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
-	echo "usage: $0 <ref> <oldrev> <newrev>" >&2
-	exit 1
-fi
-
-# --- Config
-allowunannotated=$(git config --type=bool hooks.allowunannotated)
-allowdeletebranch=$(git config --type=bool hooks.allowdeletebranch)
warning: in the working copy of 'sdl_original/.git/info/exclude', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/logs/HEAD', LF will be replaced by CRLF the next time Git touches it
-denycreatebranch=$(git config --type=bool hooks.denycreatebranch)
-allowdeletetag=$(git config --type=bool hooks.allowdeletetag)
-allowmodifytag=$(git config --type=bool hooks.allowmodifytag)
-
-# check for no description
-projectdesc=$(sed -e '1q' "$GIT_DIR/description")
-case "$projectdesc" in
-"Unnamed repository"* | "")
-	echo "*** Project description file hasn't been set" >&2
-	exit 1
-	;;
-esac
-
-# --- Check types
-# if $newrev is 0000...0000, it's a commit to delete a ref.
-zero=$(git hash-object --stdin </dev/null | tr '[0-9a-f]' '0')
-if [ "$newrev" = "$zero" ]; then
-	newrev_type=delete
-else
-	newrev_type=$(git cat-file -t $newrev)
-fi
-
-case "$refname","$newrev_type" in
-	refs/tags/*,commit)
-		# un-annotated tag
-		short_refname=${refname##refs/tags/}
-		if [ "$allowunannotated" != "true" ]; then
-			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
-			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,delete)
-		# delete tag
-		if [ "$allowdeletetag" != "true" ]; then
-			echo "*** Deleting a tag is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/tags/*,tag)
-		# annotated tag
-		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
-		then
-			echo "*** Tag '$refname' already exists." >&2
-			echo "*** Modifying a tag is not allowed in this repository." >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,commit)
-		# branch
-		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
-			echo "*** Creating a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/heads/*,delete)
-		# delete branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	refs/remotes/*,commit)
-		# tracking branch
-		;;
-	refs/remotes/*,delete)
-		# delete tracking branch
-		if [ "$allowdeletebranch" != "true" ]; then
-			echo "*** Deleting a tracking branch is not allowed in this repository" >&2
-			exit 1
-		fi
-		;;
-	*)
-		# Anything else (is there anything else?)
-		echo "*** Update hook: unknown type of update to ref $refname of type $newrev_type" >&2
-		exit 1
-		;;
-esac
-
-# --- Finished
-exit 0
diff --git a/sdl_original/.git/index b/sdl_original/.git/index
deleted file mode 100644
index 286c365..0000000
Binary files a/sdl_original/.git/index and /dev/null differ
diff --git a/sdl_original/.git/info/exclude b/sdl_original/.git/info/exclude
deleted file mode 100644
index a5196d1..0000000
--- a/sdl_original/.git/info/exclude
+++ /dev/null
@@ -1,6 +0,0 @@
-# git ls-files --others --exclude-from=.git/info/exclude
-# Lines that start with '#' are comments.
-# For a project mostly in C, the following would be a good set of
-# exclude patterns (uncomment them if you want to use them):
-# *.[oa]
-# *~
diff --git a/sdl_original/.git/logs/HEAD b/sdl_original/.git/logs/HEAD
deleted file mode 100644
index 98d84a6..0000000
--- a/sdl_original/.git/logs/HEAD
+++ /dev/null
@@ -1 +0,0 @@
-0000000000000000000000000000000000000000 5adbf3765a57dc5931c2a3137390bfee2370c945 FireworkSky <1773931858@qq.com> 1769598908 +0800	clone: from https://github.com/libsdl-org/SDL.git
diff --git a/sdl_original/.git/objects/pack/pack-57aa2a284d60cd3c9ea2f7654198d96f1fefc674.idx b/sdl_original/.git/objects/pack/pack-57aa2a284d60cd3c9ea2f7654198d96f1fefc674.idx
deleted file mode 100644
index 6b2ab01..0000000
Binary files a/sdl_original/.git/objects/pack/pack-57aa2a284d60cd3c9ea2f7654198d96f1fefc674.idx and /dev/null differ
diff --git a/sdl_original/.git/objects/pack/pack-57aa2a284d60cd3c9ea2f7654198d96f1fefc674.pack b/sdl_original/.git/objects/pack/pack-57aa2a284d60cd3c9ea2f7654198d96f1fefc674.pack
deleted file mode 100644
index 78ac083..0000000
Binary files a/sdl_original/.git/objects/pack/pack-57aa2a284d60cd3c9ea2f7654198d96f1fefc674.pack and /dev/null differ
diff --git a/sdl_original/.git/objects/pack/pack-57aa2a284d60cd3c9ea2f7654198d96f1fefc674.rev b/sdl_original/.git/objects/pack/pack-57aa2a284d60cd3c9ea2f7654198d96f1fefc674.rev
deleted file mode 100644
warning: in the working copy of 'sdl_original/.git/packed-refs', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'sdl_original/.git/shallow', LF will be replaced by CRLF the next time Git touches it
index f953bdf..0000000
Binary files a/sdl_original/.git/objects/pack/pack-57aa2a284d60cd3c9ea2f7654198d96f1fefc674.rev and /dev/null differ
diff --git a/sdl_original/.git/packed-refs b/sdl_original/.git/packed-refs
deleted file mode 100644
index 3ae46c6..0000000
--- a/sdl_original/.git/packed-refs
+++ /dev/null
@@ -1,2 +0,0 @@
-# pack-refs with: peeled fully-peeled sorted 
-5adbf3765a57dc5931c2a3137390bfee2370c945 refs/tags/release-2.30.1
diff --git a/sdl_original/.git/shallow b/sdl_original/.git/shallow
deleted file mode 100644
index e8ffb86..0000000
--- a/sdl_original/.git/shallow
+++ /dev/null
@@ -1 +0,0 @@
-5adbf3765a57dc5931c2a3137390bfee2370c945
diff --git a/sdl_original/.github/workflows/android.yml b/app/src/main/cpp/SDL/.github/workflows/android.yml
index a2d2b0b..f68022e 100644
--- a/sdl_original/.github/workflows/android.yml
+++ b/app/src/main/cpp/SDL/.github/workflows/android.yml
@@ -24,6 +24,13 @@ jobs:
         if: ${{ matrix.platform.name == 'Android.mk' }}
         run: |
           ./build-scripts/androidbuildlibs.sh
+
+      - uses: actions/upload-artifact@v4
+        if: ${{ matrix.platform.name == 'Android.mk' }}
+        with:
+          name: SDL2 Artifacts (Android)
+          path: build/android/lib
+
       - name: Setup (CMake)
         if: ${{ matrix.platform.name == 'CMake' }}
         run: |
diff --git a/sdl_original/.github/workflows/ios.yml b/app/src/main/cpp/SDL/.github/workflows/ios.yml
index 1eb5735..186a885 100644
--- a/sdl_original/.github/workflows/ios.yml
+++ b/app/src/main/cpp/SDL/.github/workflows/ios.yml
@@ -12,9 +12,16 @@ jobs:
       matrix:
         platform:
         - { name: iOS, target: Static Library-iOS, sdk: iphoneos }
+        - { name: iOS Sim, target: Static Library-iOS, sdk: iphonesimulator }
         - { name: tvOS, target: Static Library-tvOS, sdk: appletvos }
+        - { name: tvOS Sim, target: Static Library-tvOS, sdk: appletvsimulator }
 
     steps:
       - uses: actions/checkout@v4
       - name: Build
-        run: xcodebuild -project Xcode/SDL/SDL.xcodeproj -target '${{ matrix.platform.target }}' -configuration Release -sdk ${{ matrix.platform.sdk }} clean build
\ No newline at end of file
+        run: xcodebuild -project Xcode/SDL/SDL.xcodeproj -target '${{ matrix.platform.target }}' -configuration Release -sdk ${{ matrix.platform.sdk }} OTHER_CFLAGS="-fno-objc-msgsend-selector-stubs" GCC_PREPROCESSOR_DEFINITIONS='$GCC_PREPROCESSOR_DEFINITIONS SDL_MAIN_HANDLED=1' clean build
+
+      - uses: actions/upload-artifact@v4
+        with:
+          name: SDL2 Artifacts ${{ matrix.platform.name }}
+          path: Xcode/SDL/build/Release-*/*.a
diff --git a/sdl_original/.github/workflows/main.yml b/app/src/main/cpp/SDL/.github/workflows/main.yml
index 223d404..794a853 100644
--- a/sdl_original/.github/workflows/main.yml
+++ b/app/src/main/cpp/SDL/.github/workflows/main.yml
@@ -99,12 +99,22 @@ jobs:
         -DSDL_VENDOR_INFO="Github Workflow" \
         -DCMAKE_INSTALL_PREFIX=cmake_prefix \
         -DCMAKE_BUILD_TYPE=Release \
+        -DCMAKE_OSX_DEPLOYMENT_TARGET=11 \
         ${{ matrix.platform.cmake }}
     - name: Build (CMake)
       if: "! matrix.platform.autotools"
       run: |
         ${{ matrix.platform.source_cmd }}
         cmake --build build/ --config Release --verbose --parallel
+
+    - uses: actions/upload-artifact@v4
+      if: "matrix.platform.name == 'MacOS (CMake)' || matrix.platform.name == 'Ubuntu 22.04 (CMake)'"
+      with:
+        name: SDL2 Artifacts ${{ matrix.platform.name }}
+        path: |
+          build/libSDL2-2.0.0.dylib
+          build/libSDL2-2.0.so.0
+
     - name: Run build-time tests (CMake)
       if: "! matrix.platform.autotools"
       run: |
diff --git a/sdl_original/.github/workflows/msvc.yml b/app/src/main/cpp/SDL/.github/workflows/msvc.yml
index 241cc55..a56f096 100644
--- a/sdl_original/.github/workflows/msvc.yml
+++ b/app/src/main/cpp/SDL/.github/workflows/msvc.yml
@@ -78,3 +78,13 @@ jobs:
     - name: Build msbuild
       if: ${{ matrix.platform.project != '' }}
       run: msbuild ${{ matrix.platform.project }} /m /p:BuildInParallel=true /p:Configuration=Release ${{ matrix.platform.projectflags }}
+
+    - uses: actions/upload-artifact@v4
+      if: ${{ matrix.platform.name == 'Windows (x64)' || matrix.platform.name == 'UWP (x64)' }}
+      with:
+        name: SDL2 Artifacts ${{ matrix.platform.name }}
+        path: |
+          VisualC/x64/Release/*.dll
+          VisualC/x64/Release/*.lib
+          VisualC-WinRT/x64/Release/SDL-UWP/*.dll
+          VisualC-WinRT/x64/Release/SDL-UWP/*.pri
diff --git a/sdl_original/Android.mk b/app/src/main/cpp/SDL/Android.mk
index 9c9a160..fe664ab 100644
--- a/sdl_original/Android.mk
+++ b/app/src/main/cpp/SDL/Android.mk
@@ -123,8 +123,11 @@ LOCAL_C_INCLUDES := $(LOCAL_PATH)/include
 
 LOCAL_MODULE := SDL2_main
 
-LOCAL_MODULE_FILENAME := libSDL2main
+LOCAL_SRC_FILES := \
+	$(wildcard $(LOCAL_PATH)/src/main/android/*.c)
 
-include $(BUILD_STATIC_LIBRARY)
+LOCAL_MODULE_FILENAME := libmain
+
+include $(BUILD_SHARED_LIBRARY)
 
 $(call import-module,android/cpufeatures)
diff --git a/sdl_original/VisualC/pkg-support/cmake/sdl2-config-version.cmake b/sdl_original/VisualC/pkg-support/cmake/sdl2-config-version.cmake
deleted file mode 100644
index 42bb6e7..0000000
--- a/sdl_original/VisualC/pkg-support/cmake/sdl2-config-version.cmake
+++ /dev/null
@@ -1,54 +0,0 @@
-# based on the files generated by CMake's write_basic_package_version_file
-
-# SDL2 CMake version configuration file:
-# This file is meant to be placed in a cmake subfolder of SDL2-devel-2.x.y-VC
-
-if(NOT EXISTS "${CMAKE_CURRENT_LIST_DIR}/../include/SDL_version.h")
-    message(AUTHOR_WARNING "Could not find SDL_version.h. This script is meant to be placed in the root of SDL2-devel-2.x.y-VC")
-    return()
-endif()
-
-file(READ "${CMAKE_CURRENT_LIST_DIR}/../include/SDL_version.h" _sdl_version_h)
-string(REGEX MATCH "#define[ \t]+SDL_MAJOR_VERSION[ \t]+([0-9]+)" _sdl_major_re "${_sdl_version_h}")
-set(_sdl_major "${CMAKE_MATCH_1}")
-string(REGEX MATCH "#define[ \t]+SDL_MINOR_VERSION[ \t]+([0-9]+)" _sdl_minor_re "${_sdl_version_h}")
-set(_sdl_minor "${CMAKE_MATCH_1}")
-string(REGEX MATCH "#define[ \t]+SDL_PATCHLEVEL[ \t]+([0-9]+)" _sdl_patch_re "${_sdl_version_h}")
-set(_sdl_patch "${CMAKE_MATCH_1}")
-if(_sdl_major_re AND _sdl_minor_re AND _sdl_patch_re)
-    set(PACKAGE_VERSION "${_sdl_major}.${_sdl_minor}.${_sdl_patch}")
-else()
-    message(AUTHOR_WARNING "Could not extract version from SDL_version.h.")
-    return()
-endif()
-
-if(PACKAGE_FIND_VERSION_RANGE)
-    # Package version must be in the requested version range
-    if ((PACKAGE_FIND_VERSION_RANGE_MIN STREQUAL "INCLUDE" AND PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION_MIN)
-        OR ((PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "INCLUDE" AND PACKAGE_VERSION VERSION_GREATER PACKAGE_FIND_VERSION_MAX)
-        OR (PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "EXCLUDE" AND PACKAGE_VERSION VERSION_GREATER_EQUAL PACKAGE_FIND_VERSION_MAX)))
-        set(PACKAGE_VERSION_COMPATIBLE FALSE)
-    else()
-        set(PACKAGE_VERSION_COMPATIBLE TRUE)
-    endif()
-else()
-    if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
-        set(PACKAGE_VERSION_COMPATIBLE FALSE)
-    else()
-        set(PACKAGE_VERSION_COMPATIBLE TRUE)
-        if(PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)
-            set(PACKAGE_VERSION_EXACT TRUE)
-        endif()
-    endif()
-endif()
-
-# if the using project doesn't have CMAKE_SIZEOF_VOID_P set, fail.
-if("${CMAKE_SIZEOF_VOID_P}" STREQUAL "")
-    set(PACKAGE_VERSION_UNSUITABLE TRUE)
-endif()
-
-# check that the installed version has the same 32/64bit-ness as the one which is currently searching:
-if(NOT (CMAKE_SIZEOF_VOID_P STREQUAL "8" OR CMAKE_SIZEOF_VOID_P STREQUAL "4"))
-    set(PACKAGE_VERSION "${PACKAGE_VERSION} (32+64bit)")
-    set(PACKAGE_VERSION_UNSUITABLE TRUE)
-endif()
diff --git a/sdl_original/VisualC/pkg-support/cmake/sdl2-config.cmake b/sdl_original/VisualC/pkg-support/cmake/sdl2-config.cmake
deleted file mode 100644
index e54f470..0000000
--- a/sdl_original/VisualC/pkg-support/cmake/sdl2-config.cmake
+++ /dev/null
@@ -1,117 +0,0 @@
-# SDL2 CMake configuration file:
-# This file is meant to be placed in a cmake subfolder of SDL2-devel-2.x.y-VC
-
-cmake_minimum_required(VERSION 3.0...3.5)
-
-include(FeatureSummary)
-set_package_properties(SDL2 PROPERTIES
-    URL "https://www.libsdl.org/"
-    DESCRIPTION "low level access to audio, keyboard, mouse, joystick, and graphics hardware"
-)
-
-# Copied from `configure_package_config_file`
-macro(set_and_check _var _file)
-    set(${_var} "${_file}")
-    if(NOT EXISTS "${_file}")
-        message(FATAL_ERROR "File or directory ${_file} referenced by variable ${_var} does not exist !")
-    endif()
-endmacro()
-
-# Copied from `configure_package_config_file`
-macro(check_required_components _NAME)
-    foreach(comp ${${_NAME}_FIND_COMPONENTS})
-        if(NOT ${_NAME}_${comp}_FOUND)
-            if(${_NAME}_FIND_REQUIRED_${comp})
-                set(${_NAME}_FOUND FALSE)
-            endif()
-        endif()
-    endforeach()
-endmacro()
-
-set(SDL2_FOUND TRUE)
-
-if(CMAKE_SIZEOF_VOID_P STREQUAL "4")
-    set(_sdl_arch_subdir "x86")
-elseif(CMAKE_SIZEOF_VOID_P STREQUAL "8")
-    set(_sdl_arch_subdir "x64")
-else()
-    set(SDL2_FOUND FALSE)
-    return()
-endif()
-
-# For compatibility with autotools sdl2-config.cmake, provide SDL2_* variables.
-
-set_and_check(SDL2_PREFIX       "${CMAKE_CURRENT_LIST_DIR}/..")
-set_and_check(SDL2_EXEC_PREFIX  "${CMAKE_CURRENT_LIST_DIR}/..")
-set_and_check(SDL2_INCLUDE_DIR  "${SDL2_PREFIX}/include")
-set(SDL2_INCLUDE_DIRS           "${SDL2_INCLUDE_DIR}")
-set_and_check(SDL2_BINDIR       "${SDL2_PREFIX}/lib/${_sdl_arch_subdir}")
-set_and_check(SDL2_LIBDIR       "${SDL2_PREFIX}/lib/${_sdl_arch_subdir}")
-
-set(SDL2_LIBRARIES      SDL2::SDL2main SDL2::SDL2)
-set(SDL2MAIN_LIBRARY    SDL2::SDL2main)
-set(SDL2TEST_LIBRARY    SDL2::SDL2test)
-
-
-# All targets are created, even when some might not be requested though COMPONENTS.
-# This is done for compatibility with CMake generated SDL2-target.cmake files.
-
-set(_sdl2_library     "${SDL2_LIBDIR}/SDL2.lib")
-set(_sdl2_dll_library "${SDL2_BINDIR}/SDL2.dll")
-if(EXISTS "${_sdl2_library}" AND EXISTS "${_sdl2_dll_library}")
-    if(NOT TARGET SDL2::SDL2)
-        add_library(SDL2::SDL2 SHARED IMPORTED)
-        set_target_properties(SDL2::SDL2
-            PROPERTIES
-                INTERFACE_INCLUDE_DIRECTORIES "${SDL2_INCLUDE_DIRS}"
-                IMPORTED_IMPLIB "${_sdl2_library}"
-                IMPORTED_LOCATION "${_sdl2_dll_library}"
-                COMPATIBLE_INTERFACE_BOOL "SDL2_SHARED"
-                INTERFACE_SDL2_SHARED "ON"
-                COMPATIBLE_INTERFACE_STRING "SDL_VERSION"
-                INTERFACE_SDL_VERSION "SDL2"
-        )
-    endif()
-    set(SDL2_SDL2_FOUND TRUE)
-else()
-    set(SDL2_SDL2_FOUND FALSE)
-endif()
-unset(_sdl2_library)
-unset(_sdl2_dll_library)
-
-set(_sdl2main_library "${SDL2_LIBDIR}/SDL2main.lib")
-if(EXISTS "${_sdl2main_library}")
-    if(NOT TARGET SDL2::SDL2main)
-        add_library(SDL2::SDL2main STATIC IMPORTED)
-        set_target_properties(SDL2::SDL2main
-        PROPERTIES
-            IMPORTED_LOCATION "${_sdl2main_library}"
-            COMPATIBLE_INTERFACE_STRING "SDL_VERSION"
-            INTERFACE_SDL_VERSION "SDL2"
-        )
-    endif()
-    set(SDL2_SDL2main_FOUND TRUE)
-else()
-    set(SDL2_SDL2_FOUND FALSE)
-endif()
-unset(_sdl2main_library)
-
-set(_sdl2test_library "${SDL2_LIBDIR}/SDL2test.lib")
-if(EXISTS "${_sdl2test_library}")
-    if(NOT TARGET SDL2::SDL2test)
-        add_library(SDL2::SDL2test STATIC IMPORTED)
-        set_target_properties(SDL2::SDL2test
-            PROPERTIES
-                INTERFACE_INCLUDE_DIRECTORIES "${SDL2_INCLUDE_DIRS}"
-                IMPORTED_LOCATION "${_sdl2test_library}"
-                COMPATIBLE_INTERFACE_STRING "SDL_VERSION"
-                INTERFACE_SDL_VERSION "SDL2"
-        )
-    endif()
-    set(SDL2_SDL2test_FOUND TRUE)
-else()
-    set(SDL2_SDL2_FOUND FALSE)
-endif()
-unset(_sdl2test_library)
-
-check_required_components(SDL2)
diff --git a/sdl_original/Xcode/SDL/pkg-support/resources/CMake/sdl2-config-version.cmake b/sdl_original/Xcode/SDL/pkg-support/resources/CMake/sdl2-config-version.cmake
deleted file mode 100644
index feea76e..0000000
--- a/sdl_original/Xcode/SDL/pkg-support/resources/CMake/sdl2-config-version.cmake
+++ /dev/null
@@ -1,48 +0,0 @@
-# based on the files generated by CMake's write_basic_package_version_file
-
-# SDL2 CMake version configuration file:
-# This file is meant to be placed in Resources/CMake of a SDL2 framework
-
-if(NOT EXISTS "${CMAKE_CURRENT_LIST_DIR}/../../Headers/SDL_version.h")
-    message(AUTHOR_WARNING "Could not find SDL_version.h. This script is meant to be placed in the Resources/CMake directory of SDL2.framework")
-    return()
-endif()
-
-file(READ "${CMAKE_CURRENT_LIST_DIR}/../../Headers/SDL_version.h" _sdl_version_h)
-string(REGEX MATCH "#define[ \t]+SDL_MAJOR_VERSION[ \t]+([0-9]+)" _sdl_major_re "${_sdl_version_h}")
-set(_sdl_major "${CMAKE_MATCH_1}")
-string(REGEX MATCH "#define[ \t]+SDL_MINOR_VERSION[ \t]+([0-9]+)" _sdl_minor_re "${_sdl_version_h}")
-set(_sdl_minor "${CMAKE_MATCH_1}")
-string(REGEX MATCH "#define[ \t]+SDL_PATCHLEVEL[ \t]+([0-9]+)" _sdl_patch_re "${_sdl_version_h}")
-set(_sdl_patch "${CMAKE_MATCH_1}")
-if(_sdl_major_re AND _sdl_minor_re AND _sdl_patch_re)
-    set(PACKAGE_VERSION "${_sdl_major}.${_sdl_minor}.${_sdl_patch}")
-else()
-    message(AUTHOR_WARNING "Could not extract version from SDL_version.h.")
-    return()
-endif()
-
-if(PACKAGE_FIND_VERSION_RANGE)
-    # Package version must be in the requested version range
-    if ((PACKAGE_FIND_VERSION_RANGE_MIN STREQUAL "INCLUDE" AND PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION_MIN)
-        OR ((PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "INCLUDE" AND PACKAGE_VERSION VERSION_GREATER PACKAGE_FIND_VERSION_MAX)
-        OR (PACKAGE_FIND_VERSION_RANGE_MAX STREQUAL "EXCLUDE" AND PACKAGE_VERSION VERSION_GREATER_EQUAL PACKAGE_FIND_VERSION_MAX)))
-        set(PACKAGE_VERSION_COMPATIBLE FALSE)
-    else()
-        set(PACKAGE_VERSION_COMPATIBLE TRUE)
-    endif()
-else()
-    if(PACKAGE_VERSION VERSION_LESS PACKAGE_FIND_VERSION)
-        set(PACKAGE_VERSION_COMPATIBLE FALSE)
-    else()
-        set(PACKAGE_VERSION_COMPATIBLE TRUE)
-        if(PACKAGE_FIND_VERSION STREQUAL PACKAGE_VERSION)
-            set(PACKAGE_VERSION_EXACT TRUE)
-        endif()
-    endif()
-endif()
-
-# if the using project doesn't have CMAKE_SIZEOF_VOID_P set, fail.
-if("${CMAKE_SIZEOF_VOID_P}" STREQUAL "")
-    set(PACKAGE_VERSION_UNSUITABLE TRUE)
-endif()
diff --git a/sdl_original/Xcode/SDL/pkg-support/resources/CMake/sdl2-config.cmake b/sdl_original/Xcode/SDL/pkg-support/resources/CMake/sdl2-config.cmake
deleted file mode 100644
index 9205d1f..0000000
--- a/sdl_original/Xcode/SDL/pkg-support/resources/CMake/sdl2-config.cmake
+++ /dev/null
@@ -1,78 +0,0 @@
-# SDL2 CMake configuration file:
-# This file is meant to be placed in Resources/CMake of a SDL2 framework
-
-# INTERFACE_LINK_OPTIONS needs CMake 3.12
-cmake_minimum_required(VERSION 3.12)
-
-include(FeatureSummary)
-set_package_properties(SDL2 PROPERTIES
-    URL "https://www.libsdl.org/"
-    DESCRIPTION "low level access to audio, keyboard, mouse, joystick, and graphics hardware"
-)
-
-# Copied from `configure_package_config_file`
-macro(set_and_check _var _file)
-    set(${_var} "${_file}")
-    if(NOT EXISTS "${_file}")
-        message(FATAL_ERROR "File or directory ${_file} referenced by variable ${_var} does not exist !")
-    endif()
-endmacro()
-
-# Copied from `configure_package_config_file`
-macro(check_required_components _NAME)
-    foreach(comp ${${_NAME}_FIND_COMPONENTS})
-        if(NOT ${_NAME}_${comp}_FOUND)
-            if(${_NAME}_FIND_REQUIRED_${comp})
-                set(${_NAME}_FOUND FALSE)
-            endif()
-        endif()
-    endforeach()
-endmacro()
-
-set(SDL2_FOUND TRUE)
-
-# Compute the installation prefix relative to this file.
-set(SDL2_FRAMEWORK_PATH "${CMAKE_CURRENT_LIST_DIR}")                                # > /SDL2.framework/Resources/CMake/
-get_filename_component(SDL2_FRAMEWORK_PATH "${SDL2_FRAMEWORK_PATH}" REALPATH)       # > /SDL2.framework/Versions/Current/Resources/CMake
-get_filename_component(SDL2_FRAMEWORK_PATH "${SDL2_FRAMEWORK_PATH}" REALPATH)       # > /SDL2.framework/Versions/A/Resources/CMake/
-get_filename_component(SDL2_FRAMEWORK_PATH "${SDL2_FRAMEWORK_PATH}" PATH)           # > /SDL2.framework/Versions/A/Resources/
-get_filename_component(SDL2_FRAMEWORK_PATH "${SDL2_FRAMEWORK_PATH}" PATH)           # > /SDL2.framework/Versions/A/
-get_filename_component(SDL2_FRAMEWORK_PATH "${SDL2_FRAMEWORK_PATH}" PATH)           # > /SDL2.framework/Versions/
-get_filename_component(SDL2_FRAMEWORK_PATH "${SDL2_FRAMEWORK_PATH}" PATH)           # > /SDL2.framework/
-get_filename_component(SDL2_FRAMEWORK_PARENT_PATH "${SDL2_FRAMEWORK_PATH}" PATH)    # > /
-
-# For compatibility with autotools sdl2-config.cmake, provide SDL2_* variables.
-
-set_and_check(SDL2_PREFIX       "${SDL2_FRAMEWORK_PATH}")
-set_and_check(SDL2_EXEC_PREFIX  "${SDL2_FRAMEWORK_PATH}")
-set_and_check(SDL2_INCLUDE_DIR  "${SDL2_FRAMEWORK_PATH}/Headers")
-set(SDL2_INCLUDE_DIRS           "${SDL2_INCLUDE_DIR};${SDL2_FRAMEWORK_PATH}")
-set_and_check(SDL2_BINDIR       "${SDL2_FRAMEWORK_PATH}")
-set_and_check(SDL2_LIBDIR       "${SDL2_FRAMEWORK_PATH}")
-
-set(SDL2_LIBRARIES "SDL2::SDL2")
-
-# All targets are created, even when some might not be requested though COMPONENTS.
-# This is done for compatibility with CMake generated SDL2-target.cmake files.
-
-if(NOT TARGET SDL2::SDL2)
-    add_library(SDL2::SDL2 SHARED IMPORTED)
-    set_target_properties(SDL2::SDL2
-        PROPERTIES
-            FRAMEWORK "TRUE"
-            IMPORTED_LOCATION "${SDL2_FRAMEWORK_PATH}/Versions/A/SDL2"
-            INTERFACE_INCLUDE_DIRECTORIES "${SDL2_INCLUDE_DIRS}"
-            COMPATIBLE_INTERFACE_BOOL "SDL2_SHARED"
-            INTERFACE_SDL2_SHARED "ON"
-            COMPATIBLE_INTERFACE_STRING "SDL_VERSION"
-            INTERFACE_SDL_VERSION "SDL2"
-    )
-endif()
-set(SDL2_SDL2_FOUND TRUE)
-
-if(NOT TARGET SDL2::SDL2main)
-    add_library(SDL2::SDL2main INTERFACE IMPORTED)
-endif()
-set(SDL2_SDL2main_FOUND TRUE)
-
-check_required_components(SDL2)
diff --git a/sdl_original/android-project/app/src/main/java/org/libsdl/app/SDLAudioManager.java b/app/src/main/cpp/SDL/android-project/app/src/main/java/org/libsdl/app/SDLAudioManager.java
index 7c821a4..192ade5 100644
--- a/sdl_original/android-project/app/src/main/java/org/libsdl/app/SDLAudioManager.java
+++ b/app/src/main/cpp/SDL/android-project/app/src/main/java/org/libsdl/app/SDLAudioManager.java
@@ -77,6 +77,16 @@ public class SDLAudioManager {
         int frameSize;
 
         Log.v(TAG, "Opening " + (isCapture ? "capture" : "playback") + ", requested " + desiredFrames + " frames of " + desiredChannels + " channel " + getAudioFormatString(audioFormat) + " audio at " + sampleRate + " Hz");
+        
+        // Get native sample rate for better audio quality
+        if (!isCapture && mContext != null && Build.VERSION.SDK_INT >= 17 /* Android 4.2 (JELLY_BEAN_MR1) */) {
+            AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);
+            String nativeSampleRateStr = am.getProperty(AudioManager.PROPERTY_OUTPUT_SAMPLE_RATE);
+            if (nativeSampleRateStr != null) {
+                int nativeSampleRate = Integer.parseInt(nativeSampleRateStr);
+                Log.v(TAG, "Device native sample rate: " + nativeSampleRate + " Hz, requested: " + sampleRate + " Hz");
+            }
+        }
 
         /* On older devices let's use known good settings */
         if (Build.VERSION.SDK_INT < 21 /* Android 5.0 (LOLLIPOP) */) {
@@ -221,6 +231,11 @@ public class SDLAudioManager {
             minBufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat);
         }
         desiredFrames = Math.max(desiredFrames, (minBufferSize + frameSize - 1) / frameSize);
+        
+        // Increase buffer size to reduce audio glitches/crackling on Android
+        // Especially important for emulated games that may have timing variations
+        desiredFrames = Math.max(desiredFrames, 4096);
+        Log.v(TAG, "Using buffer size: " + desiredFrames + " frames (min was " + ((minBufferSize + frameSize - 1) / frameSize) + ")");
 
         int[] results = new int[4];
 
@@ -250,7 +265,42 @@ public class SDLAudioManager {
 
         } else {
             if (mAudioTrack == null) {
-                mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate, channelConfig, audioFormat, desiredFrames * frameSize, AudioTrack.MODE_STREAM);
+                int bufferSizeInBytes = desiredFrames * frameSize;
+                
+                // Use modern AudioTrack.Builder API for better performance on Android 5.0+
+                if (Build.VERSION.SDK_INT >= 21 /* Android 5.0 (LOLLIPOP) */) {
+                    try {
+                        android.media.AudioAttributes audioAttributes = new android.media.AudioAttributes.Builder()
+                                .setUsage(android.media.AudioAttributes.USAGE_GAME)
+                                .setContentType(android.media.AudioAttributes.CONTENT_TYPE_SONIFICATION)
+                                .build();
+                        
+                        AudioFormat audioFormatObj = new AudioFormat.Builder()
+                                .setSampleRate(sampleRate)
+                                .setEncoding(audioFormat)
+                                .setChannelMask(channelConfig)
+                                .build();
+                        
+                        AudioTrack.Builder builder = new AudioTrack.Builder()
+                                .setAudioAttributes(audioAttributes)
+                                .setAudioFormat(audioFormatObj)
+                                .setBufferSizeInBytes(bufferSizeInBytes)
+                                .setTransferMode(AudioTrack.MODE_STREAM);
+                        
+                        // Set performance mode for lower latency on Android 8.0+
+                        if (Build.VERSION.SDK_INT >= 26 /* Android 8.0 (O) */) {
+                            builder.setPerformanceMode(AudioTrack.PERFORMANCE_MODE_LOW_LATENCY);
+                        }
+                        
+                        mAudioTrack = builder.build();
+                        Log.v(TAG, "Created AudioTrack using Builder API (SDK " + Build.VERSION.SDK_INT + ")");
+                    } catch (Exception e) {
+                        Log.e(TAG, "Failed to create AudioTrack with Builder, falling back to legacy: " + e.getMessage());
+                        mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate, channelConfig, audioFormat, bufferSizeInBytes, AudioTrack.MODE_STREAM);
+                    }
+                } else {
+                    mAudioTrack = new AudioTrack(AudioManager.STREAM_MUSIC, sampleRate, channelConfig, audioFormat, bufferSizeInBytes, AudioTrack.MODE_STREAM);
+                }
 
                 // Instantiating AudioTrack can "succeed" without an exception and the track may still be invalid
                 // Ref: https://android.googlesource.com/platform/frameworks/base/+/refs/heads/master/media/java/android/media/AudioTrack.java
diff --git a/sdl_original/android-project/build.gradle b/app/src/main/cpp/SDL/android-project/build.gradle
index 2c911c6..2d877c3 100644
--- a/sdl_original/android-project/build.gradle
+++ b/app/src/main/cpp/SDL/android-project/build.gradle
@@ -17,6 +17,8 @@ allprojects {
     repositories {
         mavenCentral()
         google()
+
+
     }
 }
 
diff --git a/sdl_original/include/SDL_hints.h b/app/src/main/cpp/SDL/include/SDL_hints.h
index e775a65..6249be1 100644
--- a/sdl_original/include/SDL_hints.h
+++ b/app/src/main/cpp/SDL/include/SDL_hints.h
@@ -1853,6 +1853,26 @@ extern "C" {
  */
 #define SDL_HINT_TOUCH_MOUSE_EVENTS    "SDL_TOUCH_MOUSE_EVENTS"
 
+/**
+ *  \brief  A variable controlling whether multi-touch gestures should generate mouse events
+ *
+ *  This is a RALCore extension for touch-to-mouse conversion with multi-finger support:
+ *    "0"       - Single-touch mode: only first finger controls mouse (default)
+ *    "1"       - Multi-touch mode:
+ *                - Each finger touch sends mouse move + left button PRESSED event
+ *                - Each finger lift sends left button RELEASED event  
+ *                - SDL_mouse.c's button state check is bypassed for touch events
+ *                - This allows multiple simultaneous clicks at different positions
+ *                - The most recently touched finger controls mouse cursor movement
+ *
+ *  Implementation: When enabled, SDL_PrivateSendMouseButton in SDL_mouse.c skips
+ *  the "buttonstate == source->buttonstate" check for SDL_TOUCH_MOUSEID events,
+ *  allowing duplicate button press events from multiple touch points.
+ *
+ *  Requires SDL_TOUCH_MOUSE_EVENTS to be enabled ("1") to take effect.
+ */
+#define SDL_HINT_TOUCH_MOUSE_MULTITOUCH    "SDL_TOUCH_MOUSE_MULTITOUCH"
+
 /**
  *  \brief  A variable controlling which touchpad should generate synthetic mouse events
  *
diff --git a/sdl_original/mingw/pkg-support/cmake/sdl2-config-version.cmake b/sdl_original/mingw/pkg-support/cmake/sdl2-config-version.cmake
deleted file mode 100644
index 9f7a8b3..0000000
--- a/sdl_original/mingw/pkg-support/cmake/sdl2-config-version.cmake
+++ /dev/null
@@ -1,19 +0,0 @@
-# SDL2 CMake version configuration file:
-# This file is meant to be placed in a cmake subfolder of SDL2-devel-2.x.y-mingw
-
-if(CMAKE_SIZEOF_VOID_P EQUAL 4)
-    set(sdl2_config_path "${CMAKE_CURRENT_LIST_DIR}/../i686-w64-mingw32/lib/cmake/SDL2/sdl2-config-version.cmake")
-elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
-    set(sdl2_config_path "${CMAKE_CURRENT_LIST_DIR}/../x86_64-w64-mingw32/lib/cmake/SDL2/sdl2-config-version.cmake")
-else()
-    set(PACKAGE_VERSION_UNSUITABLE TRUE)
-    return()
-endif()
-
-if(NOT EXISTS "${sdl2_config_path}")
-    message(WARNING "${sdl2_config_path} does not exist: MinGW development package is corrupted")
-    set(PACKAGE_VERSION_UNSUITABLE TRUE)
-    return()
-endif()
-
-include("${sdl2_config_path}")
diff --git a/sdl_original/mingw/pkg-support/cmake/sdl2-config.cmake b/sdl_original/mingw/pkg-support/cmake/sdl2-config.cmake
deleted file mode 100644
index 3c0799f..0000000
--- a/sdl_original/mingw/pkg-support/cmake/sdl2-config.cmake
+++ /dev/null
@@ -1,19 +0,0 @@
-# SDL2 CMake configuration file:
-# This file is meant to be placed in a cmake subfolder of SDL2-devel-2.x.y-mingw
-
-if(CMAKE_SIZEOF_VOID_P EQUAL 4)
-    set(sdl2_config_path "${CMAKE_CURRENT_LIST_DIR}/../i686-w64-mingw32/lib/cmake/SDL2/sdl2-config.cmake")
-elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
-    set(sdl2_config_path "${CMAKE_CURRENT_LIST_DIR}/../x86_64-w64-mingw32/lib/cmake/SDL2/sdl2-config.cmake")
-else()
-    set(SDL2_FOUND FALSE)
-    return()
-endif()
-
-if(NOT EXISTS "${sdl2_config_path}")
-    message(WARNING "${sdl2_config_path} does not exist: MinGW development package is corrupted")
-    set(SDL2_FOUND FALSE)
-    return()
-endif()
-
-include("${sdl2_config_path}")
diff --git a/sdl_original/src/SDL.c b/app/src/main/cpp/SDL/src/SDL.c
index 7065fe7..73fa8ad 100644
--- a/sdl_original/src/SDL.c
+++ b/app/src/main/cpp/SDL/src/SDL.c
@@ -569,7 +569,8 @@ const char *SDL_GetPlatform(void)
 #if defined(__AIX__)
     return "AIX";
 #elif defined(__ANDROID__)
-    return "Android";
+    // we spoof this on Android so games feels more at home
+    return "Linux";
 #elif defined(__BSDI__)
     return "BSDI";
 #elif defined(__DREAMCAST__)
diff --git a/sdl_original/src/SDL_assert.c b/app/src/main/cpp/SDL/src/SDL_assert.c
index 1ca41e7..2d55e1a 100644
--- a/sdl_original/src/SDL_assert.c
+++ b/app/src/main/cpp/SDL/src/SDL_assert.c
@@ -230,7 +230,7 @@ static SDL_assert_state SDLCALL SDL_PromptAssertion(const SDL_assert_data *data,
     window = SDL_GetFocusWindow();
     if (window) {
         if (SDL_GetWindowFlags(window) & SDL_WINDOW_FULLSCREEN) {
-            SDL_MinimizeWindow(window);
+//            SDL_MinimizeWindow(window);
         } else {
             /* !!! FIXME: ungrab the input if we're not fullscreen? */
             /* No need to mess with the window */
diff --git a/sdl_original/src/audio/aaudio/SDL_aaudio.c b/app/src/main/cpp/SDL/src/audio/aaudio/SDL_aaudio.c
index 401fef6..d4a4f00 100644
--- a/sdl_original/src/audio/aaudio/SDL_aaudio.c
+++ b/app/src/main/cpp/SDL/src/audio/aaudio/SDL_aaudio.c
@@ -78,7 +78,7 @@ static int aaudio_OpenDevice(_THIS, const char *devname)
     LOGI(__func__);
 
     SDL_assert((captureDevice == NULL) || !iscapture);
-    SDL_assert((audioDevice == NULL) || iscapture);
+//666    SDL_assert((audioDevice == NULL) || iscapture);
 
     if (iscapture) {
         if (!Android_JNI_RequestPermission("android.permission.RECORD_AUDIO")) {
@@ -116,7 +116,15 @@ static int aaudio_OpenDevice(_THIS, const char *devname)
     }
 
     ctx.AAudioStreamBuilder_setErrorCallback(ctx.builder, aaudio_errorCallback, private);
-    ctx.AAudioStreamBuilder_setPerformanceMode(ctx.builder, AAUDIO_PERFORMANCE_MODE_LOW_LATENCY);
+
+    /* Check environment variable for low latency mode */
+    {
+        const char *lowLatencyEnv = SDL_getenv("SDL_AAUDIO_LOW_LATENCY");
+        if (lowLatencyEnv && SDL_strcmp(lowLatencyEnv, "1") == 0) {
+            ctx.AAudioStreamBuilder_setPerformanceMode(ctx.builder, AAUDIO_PERFORMANCE_MODE_LOW_LATENCY);
+            LOGI("AAudio low latency mode enabled via SDL_AAUDIO_LOW_LATENCY");
+        }
+    }
 
     LOGI("AAudio Try to open %u hz %u bit chan %u %s samples %u",
          this->spec.freq, SDL_AUDIO_BITSIZE(this->spec.format),
@@ -193,7 +201,7 @@ static void aaudio_CloseDevice(_THIS)
         SDL_assert(captureDevice == this);
         captureDevice = NULL;
     } else {
-        SDL_assert(audioDevice == this);
+      //666   SDL_assert(audioDevice == this);
         audioDevice = NULL;
     }
 
@@ -239,7 +247,15 @@ static int RebuildAAudioStream(SDL_AudioDevice *device)
     }
 
     ctx.AAudioStreamBuilder_setErrorCallback(ctx.builder, aaudio_errorCallback, hidden);
-    ctx.AAudioStreamBuilder_setPerformanceMode(ctx.builder, AAUDIO_PERFORMANCE_MODE_LOW_LATENCY);
+
+    /* Check environment variable for low latency mode */
+    {
+        const char *lowLatencyEnv = SDL_getenv("SDL_AAUDIO_LOW_LATENCY");
+        if (lowLatencyEnv && SDL_strcmp(lowLatencyEnv, "1") == 0) {
+            ctx.AAudioStreamBuilder_setPerformanceMode(ctx.builder, AAUDIO_PERFORMANCE_MODE_LOW_LATENCY);
+            LOGI("AAudio low latency mode enabled via SDL_AAUDIO_LOW_LATENCY");
+        }
+    }
 
     LOGI("AAudio Try to reopen %u hz %u bit chan %u %s samples %u",
          device->spec.freq, SDL_AUDIO_BITSIZE(device->spec.format),
diff --git a/sdl_original/src/core/android/SDL_android.c b/app/src/main/cpp/SDL/src/core/android/SDL_android.c
index 60620d8..20aaafb 100644
--- a/sdl_original/src/core/android/SDL_android.c
+++ b/app/src/main/cpp/SDL/src/core/android/SDL_android.c
@@ -48,6 +48,7 @@
 #include <pthread.h>
 #include <sys/types.h>
 #include <unistd.h>
+#include <stdlib.h>  /* for getenv() */
 #include <dlfcn.h>
 
 #define SDL_JAVA_PREFIX                               org_libsdl_app
@@ -74,6 +75,12 @@ JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeRunMain)(
     JNIEnv *env, jclass cls,
     jstring library, jstring function, jobject array);
 
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvCurrent)(
+        JNIEnv *env, jclass cls);
+
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvNull)(
+        JNIEnv *env, jclass cls);
+
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeDropFile)(
     JNIEnv *env, jclass jcls,
     jstring filename);
@@ -118,6 +125,34 @@ JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouse)(
     JNIEnv *env, jclass jcls,
     jint button, jint action, jfloat x, jfloat y, jboolean relative);
 
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseDirect)(
+    JNIEnv *env, jclass jcls,
+    jint button, jint action, jfloat x, jfloat y, jboolean relative);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButton)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed, jfloat x, jfloat y);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButtonOnly)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed);
+
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateX)(
+    JNIEnv *env, jclass jcls);
+
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateY)(
+    JNIEnv *env, jclass jcls);
+
+/* ?*/
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeConsumeFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeReleaseFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId);
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeClearConsumedFingers)(
+    JNIEnv *env, jclass jcls);
+
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeAccel)(
     JNIEnv *env, jclass jcls,
     jfloat x, jfloat y, jfloat z);
@@ -174,6 +209,8 @@ static JNINativeMethod SDLActivity_tab[] = {
     { "nativeGetVersion", "()Ljava/lang/String;", SDL_JAVA_INTERFACE(nativeGetVersion) },
     { "nativeSetupJNI", "()I", SDL_JAVA_INTERFACE(nativeSetupJNI) },
     { "nativeRunMain", "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/Object;)I", SDL_JAVA_INTERFACE(nativeRunMain) },
+    {"nativeAndroidJNISetEnvCurrent", "()I", SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvCurrent)},
+    {"nativeAndroidJNISetEnvNull", "()I", SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvNull)},
     { "onNativeDropFile", "(Ljava/lang/String;)V", SDL_JAVA_INTERFACE(onNativeDropFile) },
     { "nativeSetScreenResolution", "(IIIIF)V", SDL_JAVA_INTERFACE(nativeSetScreenResolution) },
     { "onNativeResize", "()V", SDL_JAVA_INTERFACE(onNativeResize) },
@@ -186,6 +223,14 @@ static JNINativeMethod SDLActivity_tab[] = {
     { "onNativeKeyboardFocusLost", "()V", SDL_JAVA_INTERFACE(onNativeKeyboardFocusLost) },
     { "onNativeTouch", "(IIIFFF)V", SDL_JAVA_INTERFACE(onNativeTouch) },
     { "onNativeMouse", "(IIFFZ)V", SDL_JAVA_INTERFACE(onNativeMouse) },
+    { "onNativeMouseDirect", "(IIFFZ)V", SDL_JAVA_INTERFACE(onNativeMouseDirect) },
+    { "onNativeMouseButton", "(IIFF)V", SDL_JAVA_INTERFACE(onNativeMouseButton) },
+    { "onNativeMouseButtonOnly", "(II)V", SDL_JAVA_INTERFACE(onNativeMouseButtonOnly) },
+    { "nativeGetMouseStateX", "()I", SDL_JAVA_INTERFACE(nativeGetMouseStateX) },
+    { "nativeGetMouseStateY", "()I", SDL_JAVA_INTERFACE(nativeGetMouseStateY) },
+    { "nativeConsumeFingerTouch", "(I)V", SDL_JAVA_INTERFACE(nativeConsumeFingerTouch) },
+    { "nativeReleaseFingerTouch", "(I)V", SDL_JAVA_INTERFACE(nativeReleaseFingerTouch) },
+    { "nativeClearConsumedFingers", "()V", SDL_JAVA_INTERFACE(nativeClearConsumedFingers) },
     { "onNativeAccel", "(FFF)V", SDL_JAVA_INTERFACE(onNativeAccel) },
     { "onNativeClipboardChanged", "()V", SDL_JAVA_INTERFACE(onNativeClipboardChanged) },
     { "nativeLowMemory", "()V", SDL_JAVA_INTERFACE(nativeLowMemory) },
@@ -258,7 +303,7 @@ JNIEXPORT void JNICALL SDL_JAVA_CONTROLLER_INTERFACE(onNativeHat)(
 JNIEXPORT jint JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick)(
     JNIEnv *env, jclass jcls,
     jint device_id, jstring device_name, jstring device_desc, jint vendor_id, jint product_id,
-    jboolean is_accelerometer, jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs);
+    jboolean is_accelerometer, jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs, jboolean can_rumble);
 
 JNIEXPORT jint JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeRemoveJoystick)(
     JNIEnv *env, jclass jcls,
@@ -278,7 +323,7 @@ static JNINativeMethod SDLControllerManager_tab[] = {
     { "onNativePadUp", "(II)I", SDL_JAVA_CONTROLLER_INTERFACE(onNativePadUp) },
     { "onNativeJoy", "(IIF)V", SDL_JAVA_CONTROLLER_INTERFACE(onNativeJoy) },
     { "onNativeHat", "(IIII)V", SDL_JAVA_CONTROLLER_INTERFACE(onNativeHat) },
-    { "nativeAddJoystick", "(ILjava/lang/String;Ljava/lang/String;IIZIIIII)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick) },
+    { "nativeAddJoystick", "(ILjava/lang/String;Ljava/lang/String;IIZIIIIIZ)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick) },
     { "nativeRemoveJoystick", "(I)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeRemoveJoystick) },
     { "nativeAddHaptic", "(ILjava/lang/String;)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeAddHaptic) },
     { "nativeRemoveHaptic", "(I)I", SDL_JAVA_CONTROLLER_INTERFACE(nativeRemoveHaptic) }
@@ -361,6 +406,7 @@ static jclass mControllerManagerClass;
 static jmethodID midPollInputDevices;
 static jmethodID midPollHapticDevices;
 static jmethodID midHapticRun;
+static jmethodID midHapticRumble;
 static jmethodID midHapticStop;
 
 /* Accelerometer data storage */
@@ -448,6 +494,8 @@ JNIEnv *Android_JNI_GetEnv(void)
 }
 
 /* Set up an external thread for using JNI with Android_JNI_GetEnv() */
+/* EXPORTED: Used by glibc_bridge to setup JNI before Box64 execution */
+__attribute__((visibility("default")))
 int Android_JNI_SetupThread(void)
 {
     JNIEnv *env;
@@ -721,10 +769,12 @@ JNIEXPORT void JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeSetupJNI)(JNIEnv *env
                                                      "pollHapticDevices", "()V");
     midHapticRun = (*env)->GetStaticMethodID(env, mControllerManagerClass,
                                              "hapticRun", "(IFI)V");
+    midHapticRumble = (*env)->GetStaticMethodID(env, mControllerManagerClass,
+                                                "hapticRumble", "(IFFI)V");
     midHapticStop = (*env)->GetStaticMethodID(env, mControllerManagerClass,
                                               "hapticStop", "(I)V");
 
-    if (!midPollInputDevices || !midPollHapticDevices || !midHapticRun || !midHapticStop) {
+    if (!midPollInputDevices || !midPollHapticDevices || !midHapticRun || !midHapticRumble || !midHapticStop) {
         __android_log_print(ANDROID_LOG_WARN, "SDL", "Missing some Java callbacks, do you have the latest version of SDLControllerManager.java?");
     }
 
@@ -830,6 +880,14 @@ JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeRunMain)(JNIEnv *env, jclass cls,
     return status;
 }
 
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvCurrent)(JNIEnv *env, jclass cls) {
+    return Android_JNI_SetEnv(env);
+}
+
+JNIEXPORT int JNICALL SDL_JAVA_INTERFACE(nativeAndroidJNISetEnvNull)(JNIEnv *env, jclass cls) {
+    return Android_JNI_SetEnv(NULL);
+}
+
 /* Drop file */
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeDropFile)(
     JNIEnv *env, jclass jcls,
@@ -994,13 +1052,13 @@ JNIEXPORT jint JNICALL SDL_JAVA_CONTROLLER_INTERFACE(nativeAddJoystick)(
     JNIEnv *env, jclass jcls,
     jint device_id, jstring device_name, jstring device_desc,
     jint vendor_id, jint product_id, jboolean is_accelerometer,
-    jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs)
+    jint button_mask, jint naxes, jint axis_mask, jint nhats, jint nballs, jboolean can_rumble)
 {
     int retval;
     const char *name = (*env)->GetStringUTFChars(env, device_name, NULL);
     const char *desc = (*env)->GetStringUTFChars(env, device_desc, NULL);
 
-    retval = Android_AddJoystick(device_id, name, desc, vendor_id, product_id, is_accelerometer ? SDL_TRUE : SDL_FALSE, button_mask, naxes, axis_mask, nhats, nballs);
+    retval = Android_AddJoystick(device_id, name, desc, vendor_id, product_id, is_accelerometer ? SDL_TRUE : SDL_FALSE, button_mask, naxes, axis_mask, nhats, nballs, can_rumble);
 
     (*env)->ReleaseStringUTFChars(env, device_name, name);
     (*env)->ReleaseStringUTFChars(env, device_desc, desc);
@@ -1176,6 +1234,84 @@ JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouse)(
     SDL_UnlockMutex(Android_ActivityMutex);
 }
 
+/* Mouse Direct - same as onNativeMouse but without state check */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseDirect)(
+    JNIEnv *env, jclass jcls,
+    jint button, jint action, jfloat x, jfloat y, jboolean relative)
+{
+    SDL_LockMutex(Android_ActivityMutex);
+
+    Android_OnMouseDirect(Android_Window, button, action, x, y, relative);
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+/* Direct mouse button - bypasses state tracking for virtual controls */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButton)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed, jfloat x, jfloat y)
+{
+    SDL_LockMutex(Android_ActivityMutex);
+
+    Android_OnMouseButtonDirect(Android_Window, sdlButton, pressed, x, y);
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+/* Mouse button only - no cursor movement, for virtual button controls */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeMouseButtonOnly)(
+    JNIEnv *env, jclass jcls,
+    jint sdlButton, jint pressed)
+{
+    SDL_LockMutex(Android_ActivityMutex);
+
+    Android_OnMouseButtonOnly(Android_Window, sdlButton, pressed);
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+/* Get current mouse X position */
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateX)(
+    JNIEnv *env, jclass jcls)
+{
+    int x = 0;
+    SDL_GetMouseState(&x, NULL);
+    return (jint)x;
+}
+
+/* Get current mouse Y position */
+JNIEXPORT jint JNICALL SDL_JAVA_INTERFACE(nativeGetMouseStateY)(
+    JNIEnv *env, jclass jcls)
+{
+    int y = 0;
+    SDL_GetMouseState(NULL, &y);
+    return (jint)y;
+}
+
+/*  SDL_touch.c  */
+extern void SDL_ConsumeFingerTouch(int fingerId);
+extern void SDL_ReleaseFingerTouch(int fingerId);
+extern void SDL_ClearConsumedFingers(void);
+
+/* ?-  */
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeConsumeFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId)
+{
+    SDL_ConsumeFingerTouch((int)fingerId);
+}
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeReleaseFingerTouch)(
+    JNIEnv *env, jclass jcls, jint fingerId)
+{
+    SDL_ReleaseFingerTouch((int)fingerId);
+}
+
+JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(nativeClearConsumedFingers)(
+    JNIEnv *env, jclass jcls)
+{
+    SDL_ClearConsumedFingers();
+}
+
 /* Accelerometer */
 JNIEXPORT void JNICALL SDL_JAVA_INTERFACE(onNativeAccel)(
     JNIEnv *env, jclass jcls,
@@ -1406,10 +1542,35 @@ ANativeWindow *Android_JNI_GetNativeWindow(void)
     jobject s;
     JNIEnv *env = Android_JNI_GetEnv();
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "Android_JNI_GetNativeWindow called");
+    __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "  env=%p, mActivityClass=%p, midGetNativeSurface=%p",
+                        env, mActivityClass, midGetNativeSurface);
+
+    if (!env) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: JNIEnv is NULL!");
+        return NULL;
+    }
+
+    if (!mActivityClass) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: mActivityClass is NULL! nativeSetupJNI not called?");
+        return NULL;
+    }
+
+    if (!midGetNativeSurface) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: midGetNativeSurface is NULL!");
+        return NULL;
+    }
+
     s = (*env)->CallStaticObjectMethod(env, mActivityClass, midGetNativeSurface);
+    __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "  getNativeSurface() returned: %p", s);
+
     if (s) {
         anw = ANativeWindow_fromSurface(env, s);
+        __android_log_print(ANDROID_LOG_INFO, "SDL_JNI", "  ANativeWindow_fromSurface returned: %p", anw);
         (*env)->DeleteLocalRef(env, s);
+    } else {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  ERROR: getNativeSurface() returned NULL!");
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_JNI", "  This means SDLActivity.mSurface is null or Surface not ready");
     }
 
     return anw;
@@ -2155,6 +2316,7 @@ int Android_JNI_GetPowerInfo(int *plugged, int *charged, int *battery, int *seco
 /* Add all touch devices */
 void Android_JNI_InitTouch()
 {
+
     JNIEnv *env = Android_JNI_GetEnv();
     (*env)->CallStaticVoidMethod(env, mActivityClass, midInitTouch);
 }
@@ -2177,6 +2339,12 @@ void Android_JNI_HapticRun(int device_id, float intensity, int length)
     (*env)->CallStaticVoidMethod(env, mControllerManagerClass, midHapticRun, device_id, intensity, length);
 }
 
+void Android_JNI_HapticRumble(int device_id, float low_frequency_intensity, float high_frequency_intensity, int length)
+{
+    JNIEnv *env = Android_JNI_GetEnv();
+    (*env)->CallStaticVoidMethod(env, mControllerManagerClass, midHapticRumble, device_id, low_frequency_intensity, high_frequency_intensity, length);
+}
+
 void Android_JNI_HapticStop(int device_id)
 {
     JNIEnv *env = Android_JNI_GetEnv();
@@ -2550,6 +2718,14 @@ void Android_JNI_GetManifestEnvironmentVariables(void)
 
     if (!bHasEnvironmentVariables) {
         JNIEnv *env = Android_JNI_GetEnv();
+        /* Box64 fix: Check if JNIEnv is valid before using it
+         * When running from Box64 emulated threads, the JNI environment may not be
+         * properly attached, which would cause CallStaticBooleanMethod to crash. */
+        if (!env) {
+            __android_log_print(ANDROID_LOG_WARN, "SDL",
+                "Android_JNI_GetManifestEnvironmentVariables: JNIEnv is NULL, skipping (Box64 thread?)");
+            return;
+        }
         SDL_bool ret = (*env)->CallStaticBooleanMethod(env, mActivityClass, midGetManifestEnvironmentVariables);
         if (ret) {
             bHasEnvironmentVariables = SDL_TRUE;
diff --git a/sdl_original/src/core/android/SDL_android.h b/app/src/main/cpp/SDL/src/core/android/SDL_android.h
index 20d1fc5..2d8d0fa 100644
--- a/sdl_original/src/core/android/SDL_android.h
+++ b/app/src/main/cpp/SDL/src/core/android/SDL_android.h
@@ -91,6 +91,7 @@ void Android_JNI_PollInputDevices(void);
 /* Haptic support */
 void Android_JNI_PollHapticDevices(void);
 void Android_JNI_HapticRun(int device_id, float intensity, int length);
+void Android_JNI_HapticRumble(int device_id, float low_frequency_intensity, float high_frequency_intensity, int length);
 void Android_JNI_HapticStop(int device_id);
 
 /* Video */
diff --git a/sdl_original/src/events/SDL_mouse.c b/app/src/main/cpp/SDL/src/events/SDL_mouse.c
index 431354f..3105935 100644
--- a/sdl_original/src/events/SDL_mouse.c
+++ b/app/src/main/cpp/SDL/src/events/SDL_mouse.c
@@ -44,6 +44,15 @@ static SDL_Mouse SDL_mouse;
 /* for mapping mouse events to touch */
 static SDL_bool track_mouse_down = SDL_FALSE;
 
+/* Virtual mouse range limit (for game controls) */
+static SDL_bool g_vm_range_enabled = SDL_FALSE;
+static int g_vm_screen_width = 1920;
+static int g_vm_screen_height = 1080;
+static float g_vm_range_left = 1.0f;
+static float g_vm_range_top = 1.0f;
+static float g_vm_range_right = 1.0f;
+static float g_vm_range_bottom = 1.0f;
+
 static int SDL_PrivateSendMouseMotion(SDL_Window *window, SDL_MouseID mouseID, int relative, int x, int y);
 
 static void SDLCALL SDL_MouseDoubleClickTimeChanged(void *userdata, const char *name, const char *oldValue, const char *hint)
@@ -782,7 +791,17 @@ static int SDL_PrivateSendMouseButton(SDL_Window *window, SDL_MouseID mouseID, U
         SDL_UpdateMouseFocus(window, mouse->x, mouse->y, buttonstate, SDL_TRUE);
     }
 
-    if (buttonstate == source->buttonstate) {
+    /* RALCore: For multi-touch mouse emulation, skip state check when SDL_TOUCH_MOUSE_MULTITOUCH=1
+     * This allows multiple simultaneous touch points to each generate mouse events */
+    SDL_bool skip_state_check = SDL_FALSE;
+    if (mouseID == SDL_TOUCH_MOUSEID) {
+        const char* multitouch_hint = SDL_GetHint("SDL_TOUCH_MOUSE_MULTITOUCH");
+        if (multitouch_hint && SDL_strcmp(multitouch_hint, "1") == 0) {
+            skip_state_check = SDL_TRUE;
+        }
+    }
+
+    if (!skip_state_check && buttonstate == source->buttonstate) {
         /* Ignore this event, no state change */
         return 0;
     }
@@ -1501,4 +1520,48 @@ int SDL_ShowCursor(int toggle)
     return shown;
 }
 
+/* Virtual mouse range limit functions (for game controls) - exported */
+DECLSPEC void SDLCALL SDL_SetVirtualMouseRangeEnabled(SDL_bool enabled)
+{
+    g_vm_range_enabled = enabled;
+}
+
+DECLSPEC void SDLCALL SDL_SetVirtualMouseScreenSize(int width, int height)
+{
+    g_vm_screen_width = width > 0 ? width : 1920;
+    g_vm_screen_height = height > 0 ? height : 1080;
+}
+
+DECLSPEC void SDLCALL SDL_SetVirtualMouseRange(float left, float top, float right, float bottom)
+{
+    g_vm_range_left = left;
+    g_vm_range_top = top;
+    g_vm_range_right = right;
+    g_vm_range_bottom = bottom;
+}
+
+/* Apply range limit to coordinates - exported for virtual mouse usage */
+DECLSPEC void SDLCALL SDL_ApplyVirtualMouseRangeLimit(int *mouseX, int *mouseY)
+{
+    float centerX, centerY;
+    int minX, maxX, minY, maxY;
+    
+    if (!g_vm_range_enabled) {
+        return;
+    }
+    
+    centerX = g_vm_screen_width * 0.5f;
+    centerY = g_vm_screen_height * 0.5f;
+    
+    minX = (int)(centerX - (g_vm_range_left * centerX));
+    maxX = (int)(centerX + (g_vm_range_right * centerX));
+    minY = (int)(centerY - (g_vm_range_top * centerY));
+    maxY = (int)(centerY + (g_vm_range_bottom * centerY));
+    
+    if (*mouseX < minX) *mouseX = minX;
+    if (*mouseX > maxX) *mouseX = maxX;
+    if (*mouseY < minY) *mouseY = minY;
+    if (*mouseY > maxY) *mouseY = maxY;
+}
+
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/sdl_original/src/events/SDL_touch.c b/app/src/main/cpp/SDL/src/events/SDL_touch.c
index b5ec77b..ef50f2c 100644
--- a/sdl_original/src/events/SDL_touch.c
+++ b/app/src/main/cpp/SDL/src/events/SDL_touch.c
@@ -23,9 +23,15 @@
 /* General touch handling code for SDL */
 
 #include "SDL_events.h"
+#include "SDL_hints.h"
+#include "SDL_timer.h"
 #include "SDL_events_c.h"
 #include "../video/SDL_sysvideo.h"
 
+#ifdef __ANDROID__
+#include <android/log.h>
+#endif
+
 static int SDL_num_touch = 0;
 static SDL_Touch **SDL_touchDevices = NULL;
 
@@ -37,6 +43,104 @@ static SDL_Touch **SDL_touchDevices = NULL;
 static SDL_bool finger_touching = SDL_FALSE;
 static SDL_FingerID track_fingerid;
 static SDL_TouchID track_touchid;
+
+/* Multi-touch support for mouse emulation (RALCore extension)
+ * 
+ * When SDL_TOUCH_MOUSE_MULTITOUCH=1:
+ * - Each finger independently sends mouse button events
+ * - SDL_mouse.c's state check is bypassed to allow duplicate button events
+ * - The most recently touched finger controls mouse cursor movement
+ */
+#define MAX_TRACKED_FINGERS 10
+static int multitouch_finger_count = 0;
+static SDL_FingerID multitouch_fingers[MAX_TRACKED_FINGERS];
+static float multitouch_finger_x[MAX_TRACKED_FINGERS];
+static float multitouch_finger_y[MAX_TRACKED_FINGERS];
+static SDL_bool multitouch_enabled = SDL_FALSE;
+static SDL_FingerID multitouch_active_finger = 0;
+
+/* ?*/
+#define MAX_CONSUMED_FINGERS 10
+static int consumed_finger_count = 0;
+static int consumed_fingers[MAX_CONSUMED_FINGERS];
+
+/* ?*/
+static SDL_bool SDL_IsFingerConsumed(int fingerId) {
+    for (int i = 0; i < consumed_finger_count; i++) {
+        if (consumed_fingers[i] == fingerId) return SDL_TRUE;
+    }
+    return SDL_FALSE;
+}
+
+/*  Java  */
+void SDL_ConsumeFingerTouch(int fingerId) {
+    if (consumed_finger_count >= MAX_CONSUMED_FINGERS) return;
+    if (SDL_IsFingerConsumed(fingerId)) return;
+    consumed_fingers[consumed_finger_count++] = fingerId;
+#ifdef __ANDROID__
+    /* Reduced logging */
+    #if 0
+    __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouch", "Finger %d consumed by virtual control", fingerId);
+    #endif
+#endif
+}
+
+/* ?Java  */
+void SDL_ReleaseFingerTouch(int fingerId) {
+    for (int i = 0; i < consumed_finger_count; i++) {
+        if (consumed_fingers[i] == fingerId) {
+            for (int j = i; j < consumed_finger_count - 1; j++) {
+                consumed_fingers[j] = consumed_fingers[j + 1];
+            }
+            consumed_finger_count--;
+#ifdef __ANDROID__
+            __android_log_print(ANDROID_LOG_INFO, "SDLTouch", "Finger %d released", fingerId);
+#endif
+            return;
+        }
+    }
+}
+
+/* ?*/
+void SDL_ClearConsumedFingers(void) {
+    consumed_finger_count = 0;
+#ifdef __ANDROID__
+    __android_log_print(ANDROID_LOG_INFO, "SDLTouch", "All consumed fingers cleared");
+#endif
+}
+
+static int SDL_FindMultitouchFinger(SDL_FingerID fingerid) {
+    for (int i = 0; i < multitouch_finger_count; i++) {
+        if (multitouch_fingers[i] == fingerid) return i;
+    }
+    return -1;
+}
+
+static void SDL_AddMultitouchFinger(SDL_FingerID fingerid, float x, float y) {
+    if (multitouch_finger_count >= MAX_TRACKED_FINGERS) return;
+    multitouch_fingers[multitouch_finger_count] = fingerid;
+    multitouch_finger_x[multitouch_finger_count] = x;
+    multitouch_finger_y[multitouch_finger_count] = y;
+    multitouch_finger_count++;
+}
+
+static void SDL_RemoveMultitouchFinger(SDL_FingerID fingerid) {
+    int idx = SDL_FindMultitouchFinger(fingerid);
+    if (idx < 0) return;
+    for (int i = idx; i < multitouch_finger_count - 1; i++) {
+        multitouch_fingers[i] = multitouch_fingers[i + 1];
+        multitouch_finger_x[i] = multitouch_finger_x[i + 1];
+        multitouch_finger_y[i] = multitouch_finger_y[i + 1];
+    }
+    multitouch_finger_count--;
+}
+
+static void SDL_UpdateMultitouchFinger(SDL_FingerID fingerid, float x, float y) {
+    int idx = SDL_FindMultitouchFinger(fingerid);
+    if (idx < 0) return;
+    multitouch_finger_x[idx] = x;
+    multitouch_finger_y[idx] = y;
+}
 #endif
 
 /* Public functions */
@@ -248,51 +352,157 @@ int SDL_SendTouch(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window *window,
     mouse = SDL_GetMouse();
 
 #if SYNTHESIZE_TOUCH_TO_MOUSE
+    /* ?/
+    SDL_bool isConsumed = SDL_IsFingerConsumed((int)fingerid);
+#ifdef __ANDROID__
+    /* Reduced logging */
+    #if 0
+    if (isConsumed) {
+        __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouchMouse", 
+            "Finger %d is consumed by virtual control, skipping mouse events", (int)fingerid);
+    }
+    #endif
+#endif
+    
+    /* Check for multitouch mode: SDL_TOUCH_MOUSE_MULTITOUCH=1 enables multi-finger gestures */
+    {
+        const char* multitouch_hint = SDL_GetHint("SDL_TOUCH_MOUSE_MULTITOUCH");
+        multitouch_enabled = (multitouch_hint && SDL_strcmp(multitouch_hint, "1") == 0);
+    }
+    
     /* SDL_HINT_TOUCH_MOUSE_EVENTS: controlling whether touch events should generate synthetic mouse events */
     /* SDL_HINT_VITA_TOUCH_MOUSE_DEVICE: controlling which touchpad should generate synthetic mouse events, PSVita-only */
+    /*  */
     {
 #if defined(__vita__)
-        if (mouse->touch_mouse_events && ((mouse->vita_touch_mouse_device == id) || (mouse->vita_touch_mouse_device == 2))) {
+        if (mouse->touch_mouse_events && !isConsumed && ((mouse->vita_touch_mouse_device == id) || (mouse->vita_touch_mouse_device == 2))) {
 #else
-        if (mouse->touch_mouse_events) {
+        if (mouse->touch_mouse_events && !isConsumed) {
 #endif
             /* FIXME: maybe we should only restrict to a few SDL_TouchDeviceType */
             if (id != SDL_MOUSE_TOUCHID) {
                 if (window) {
-                    if (down) {
-                        if (finger_touching == SDL_FALSE) {
+                    if (multitouch_enabled) {
+                        /* Multi-touch mode: each finger sends independent mouse events
+                         * SDL_mouse.c will skip state checking when multitouch is enabled
+                         */
+                        if (down) {
                             int pos_x = (int)(x * (float)window->w);
                             int pos_y = (int)(y * (float)window->h);
-                            if (pos_x < 0) {
-                                pos_x = 0;
+                            if (pos_x < 0) pos_x = 0;
+                            if (pos_x > window->w - 1) pos_x = window->w - 1;
+                            if (pos_y < 0) pos_y = 0;
+                            if (pos_y > window->h - 1) pos_y = window->h - 1;
+                            
+                            SDL_AddMultitouchFinger(fingerid, x, y);
+                            
+                            /* This finger becomes the active one (controls mouse movement) */
+                            multitouch_active_finger = fingerid;
+                            finger_touching = SDL_TRUE;
+                            track_touchid = id;
+                            track_fingerid = fingerid;
+                            
+                            /* Send mouse move and button press - state check bypassed in SDL_mouse.c */
+                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
+                            SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                        } else {
+                            /* Finger up */
+                            int finger_idx = SDL_FindMultitouchFinger(fingerid);
+                            SDL_bool is_active = (fingerid == multitouch_active_finger);
+                            
+                            /* Send release at this finger's position */
+                            if (finger_idx >= 0) {
+                                int pos_x = (int)(multitouch_finger_x[finger_idx] * (float)window->w);
+                                int pos_y = (int)(multitouch_finger_y[finger_idx] * (float)window->h);
+                                if (pos_x < 0) pos_x = 0;
+                                if (pos_x > window->w - 1) pos_x = window->w - 1;
+                                if (pos_y < 0) pos_y = 0;
+                                if (pos_y > window->h - 1) pos_y = window->h - 1;
+                                SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
+                                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
                             }
-                            if (pos_x > window->w - 1) {
-                                pos_x = window->w - 1;
+                            
+                            SDL_RemoveMultitouchFinger(fingerid);
+                            
+                            if (is_active && multitouch_finger_count > 0) {
+                                /* Transfer active finger */
+                                multitouch_active_finger = multitouch_fingers[0];
+                                track_fingerid = multitouch_fingers[0];
+                            } else if (multitouch_finger_count == 0) {
+                                finger_touching = SDL_FALSE;
                             }
-                            if (pos_y < 0) {
-                                pos_y = 0;
+                        }
+                    } else {
+                        /* Original single-touch behavior */
+#ifdef __ANDROID__
+                        __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                            "Single-touch mode: down=%d finger_touching=%d finger=%lld track_finger=%lld",
+                            down, finger_touching, (long long)fingerid, (long long)track_fingerid);
+#endif
+                        if (down) {
+                            if (finger_touching == SDL_FALSE) {
+                                int pos_x = (int)(x * (float)window->w);
+                                int pos_y = (int)(y * (float)window->h);
+                                if (pos_x < 0) {
+                                    pos_x = 0;
+                                }
+                                if (pos_x > window->w - 1) {
+                                    pos_x = window->w - 1;
+                                }
+                                if (pos_y < 0) {
+                                    pos_y = 0;
+                                }
+                                if (pos_y > window->h - 1) {
+                                    pos_y = window->h - 1;
+                                }
+#ifdef __ANDROID__
+                                __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                                    "  -> Sending mouse DOWN at (%d,%d)", pos_x, pos_y);
+#endif
+                                SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
+                                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                            } else {
+#ifdef __ANDROID__
+                                __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                                    "  -> SKIPPED (finger_touching=TRUE)");
+#endif
                             }
-                            if (pos_y > window->h - 1) {
-                                pos_y = window->h - 1;
+                        } else {
+                            if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
+#ifdef __ANDROID__
+                                __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                                    "  -> Sending mouse UP");
+#endif
+                                SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
                             }
-                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
-                            SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_PRESSED, SDL_BUTTON_LEFT);
+                        }
+                    }
+                }
+                
+                /* Track single finger state (for non-multitouch mode) */
+                /* ?*/
+                if (!multitouch_enabled && !isConsumed) {
+                    if (down) {
+                        if (finger_touching == SDL_FALSE) {
+                            finger_touching = SDL_TRUE;
+                            track_touchid = id;
+                            track_fingerid = fingerid;
                         }
                     } else {
                         if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
-                            SDL_SendMouseButton(window, SDL_TOUCH_MOUSEID, SDL_RELEASED, SDL_BUTTON_LEFT);
+                            finger_touching = SDL_FALSE;
                         }
                     }
                 }
-                if (down) {
-                    if (finger_touching == SDL_FALSE) {
-                        finger_touching = SDL_TRUE;
-                        track_touchid = id;
-                        track_fingerid = fingerid;
-                    }
-                } else {
+                /* ?*/
+                else if (!multitouch_enabled && isConsumed && !down) {
+                    /* ?*/
                     if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
                         finger_touching = SDL_FALSE;
+#ifdef __ANDROID__
+                        __android_log_print(ANDROID_LOG_INFO, "SDLTouchMouse", 
+                            "Consumed finger released, resetting finger_touching state");
+#endif
                     }
                 }
             }
@@ -382,22 +592,39 @@ int SDL_SendTouchMotion(SDL_TouchID id, SDL_FingerID fingerid, SDL_Window *windo
         if (mouse->touch_mouse_events) {
             if (id != SDL_MOUSE_TOUCHID) {
                 if (window) {
-                    if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
-                        int pos_x = (int)(x * (float)window->w);
-                        int pos_y = (int)(y * (float)window->h);
-                        if (pos_x < 0) {
-                            pos_x = 0;
-                        }
-                        if (pos_x > window->w - 1) {
-                            pos_x = window->w - 1;
-                        }
-                        if (pos_y < 0) {
-                            pos_y = 0;
+                    if (multitouch_enabled) {
+                        /* Multi-touch mode: update finger position */
+                        SDL_UpdateMultitouchFinger(fingerid, x, y);
+                        
+                        /* Only active finger controls cursor movement */
+                        if (fingerid == multitouch_active_finger && finger_touching == SDL_TRUE) {
+                            int pos_x = (int)(x * (float)window->w);
+                            int pos_y = (int)(y * (float)window->h);
+                            if (pos_x < 0) pos_x = 0;
+                            if (pos_x > window->w - 1) pos_x = window->w - 1;
+                            if (pos_y < 0) pos_y = 0;
+                            if (pos_y > window->h - 1) pos_y = window->h - 1;
+                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                         }
-                        if (pos_y > window->h - 1) {
-                            pos_y = window->h - 1;
+                    } else {
+                        /* Original single-touch behavior */
+                        if (finger_touching == SDL_TRUE && track_touchid == id && track_fingerid == fingerid) {
+                            int pos_x = (int)(x * (float)window->w);
+                            int pos_y = (int)(y * (float)window->h);
+                            if (pos_x < 0) {
+                                pos_x = 0;
+                            }
+                            if (pos_x > window->w - 1) {
+                                pos_x = window->w - 1;
+                            }
+                            if (pos_y < 0) {
+                                pos_y = 0;
+                            }
+                            if (pos_y > window->h - 1) {
+                                pos_y = window->h - 1;
+                            }
+                            SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                         }
-                        SDL_SendMouseMotion(window, SDL_TOUCH_MOUSEID, 0, pos_x, pos_y);
                     }
                 }
             }
@@ -497,3 +724,4 @@ void SDL_TouchQuit(void)
 }
 
 /* vi: set ts=4 sw=4 expandtab: */
+
diff --git a/sdl_original/src/joystick/android/SDL_sysjoystick.c b/app/src/main/cpp/SDL/src/joystick/android/SDL_sysjoystick.c
index c29f738..850edc7 100644
--- a/sdl_original/src/joystick/android/SDL_sysjoystick.c
+++ b/app/src/main/cpp/SDL/src/joystick/android/SDL_sysjoystick.c
@@ -304,7 +304,7 @@ int Android_OnHat(int device_id, int hat_id, int x, int y)
     return -1;
 }
 
-int Android_AddJoystick(int device_id, const char *name, const char *desc, int vendor_id, int product_id, SDL_bool is_accelerometer, int button_mask, int naxes, int axis_mask, int nhats, int nballs)
+int Android_AddJoystick(int device_id, const char *name, const char *desc, int vendor_id, int product_id, SDL_bool is_accelerometer, int button_mask, int naxes, int axis_mask, int nhats, int nballs, SDL_bool can_rumble)
 {
     SDL_joylist_item *item;
     SDL_JoystickGUID guid;
@@ -379,6 +379,7 @@ int Android_AddJoystick(int device_id, const char *name, const char *desc, int v
     }
     item->naxes = naxes;
     item->nhats = nhats;
+    item->can_rumble = can_rumble;
     item->nballs = nballs;
     item->device_instance = SDL_GetNextJoystickInstanceID();
     if (!SDL_joylist_tail) {
@@ -468,7 +469,7 @@ static int ANDROID_JoystickInit(void)
 
     if (SDL_GetHintBoolean(SDL_HINT_ACCELEROMETER_AS_JOYSTICK, SDL_TRUE)) {
         /* Default behavior, accelerometer as joystick */
-        Android_AddJoystick(ANDROID_ACCELEROMETER_DEVICE_ID, ANDROID_ACCELEROMETER_NAME, ANDROID_ACCELEROMETER_NAME, 0, 0, SDL_TRUE, 0, 3, 0x0003, 0, 0);
+        Android_AddJoystick(ANDROID_ACCELEROMETER_DEVICE_ID, ANDROID_ACCELEROMETER_NAME, ANDROID_ACCELEROMETER_NAME, 0, 0, SDL_TRUE, 0, 3, 0x0003, 0, 0, SDL_FALSE);
     }
     return 0;
 }
@@ -591,7 +592,18 @@ static int ANDROID_JoystickOpen(SDL_Joystick *joystick, int device_index)
 
 static int ANDROID_JoystickRumble(SDL_Joystick *joystick, Uint16 low_frequency_rumble, Uint16 high_frequency_rumble)
 {
-    return SDL_Unsupported();
+    SDL_joylist_item *item = (SDL_joylist_item *)joystick->hwdata;
+    if (!item) {
+        return SDL_SetError("Rumble failed, device disconnected");
+    }
+    if (!item->can_rumble) {
+        return SDL_Unsupported();
+    }
+
+    float low_frequency_intensity = (float)low_frequency_rumble / SDL_MAX_UINT16;
+    float high_frequency_intensity = (float)high_frequency_rumble / SDL_MAX_UINT16;
+    Android_JNI_HapticRumble(item->device_id, low_frequency_intensity, high_frequency_intensity, 5000);
+    return 0;
 }
 
 static int ANDROID_JoystickRumbleTriggers(SDL_Joystick *joystick, Uint16 left_rumble, Uint16 right_rumble)
diff --git a/sdl_original/src/joystick/android/SDL_sysjoystick_c.h b/app/src/main/cpp/SDL/src/joystick/android/SDL_sysjoystick_c.h
index 189bcf4..1e5c44e 100644
--- a/sdl_original/src/joystick/android/SDL_sysjoystick_c.h
+++ b/app/src/main/cpp/SDL/src/joystick/android/SDL_sysjoystick_c.h
@@ -32,7 +32,7 @@ extern int Android_OnPadDown(int device_id, int keycode);
 extern int Android_OnPadUp(int device_id, int keycode);
 extern int Android_OnJoy(int device_id, int axisnum, float value);
 extern int Android_OnHat(int device_id, int hat_id, int x, int y);
-extern int Android_AddJoystick(int device_id, const char *name, const char *desc, int vendor_id, int product_id, SDL_bool is_accelerometer, int button_mask, int naxes, int axis_mask, int nhats, int nballs);
+extern int Android_AddJoystick(int device_id, const char *name, const char *desc, int vendor_id, int product_id, SDL_bool is_accelerometer, int button_mask, int naxes, int axis_mask, int nhats, int nballs, SDL_bool can_rumble);
 extern int Android_RemoveJoystick(int device_id);
 
 /* A linked list of available joysticks */
@@ -46,6 +46,7 @@ typedef struct SDL_joylist_item
     SDL_Joystick *joystick;
     int nbuttons, naxes, nhats, nballs;
     int dpad_state;
+    SDL_bool can_rumble;
 
     struct SDL_joylist_item *next;
 } SDL_joylist_item;
diff --git a/sdl_original/src/main/android/SDL_android_main.c b/app/src/main/cpp/SDL/src/main/android/SDL_android_main.c
index 054738a..c4585af 100644
--- a/sdl_original/src/main/android/SDL_android_main.c
+++ b/app/src/main/cpp/SDL/src/main/android/SDL_android_main.c
@@ -5,3 +5,22 @@
 */
 
 /* vi: set ts=4 sw=4 expandtab: */
+
+
+#define SDL_MAIN_HANDLED
+
+#include "../../SDL_internal.h"
+
+
+
+typedef void (*Main)();
+Main CurrentMain;
+
+__attribute__ ((visibility("default"))) void SetMain(Main main) {
+    CurrentMain = main;
+}
+
+__attribute__ ((visibility("default"))) int SDL_main(int argc, char* argv[]) {
+    CurrentMain();
+    return 0;
+}
diff --git a/sdl_original/src/sensor/android/SDL_androidsensor.c b/app/src/main/cpp/SDL/src/sensor/android/SDL_androidsensor.c
index 3f57253..c06faf2 100644
--- a/sdl_original/src/sensor/android/SDL_androidsensor.c
+++ b/app/src/main/cpp/SDL/src/sensor/android/SDL_androidsensor.c
@@ -161,7 +161,7 @@ static void SDL_ANDROID_SensorUpdate(SDL_Sensor *sensor)
     ASensorEvent event;
     struct android_poll_source *source;
 
-    if (ALooper_pollAll(0, NULL, &events, (void **)&source) == LOOPER_ID_USER) {
+    if (ALooper_pollOnce(0, NULL, &events, (void **)&source) == LOOPER_ID_USER) {
         SDL_zero(event);
         while (ASensorEventQueue_getEvents(sensor->hwdata->eventqueue, &event, 1) > 0) {
             SDL_PrivateSensorUpdate(sensor, 0, event.data, SDL_arraysize(event.data));
diff --git a/sdl_original/src/thread/stdcpp/SDL_syscond.cpp b/app/src/main/cpp/SDL/src/thread/stdSDL_syscond.cpp
similarity index 100%
rename from sdl_original/src/thread/stdcpp/SDL_syscond.cpp
rename to app/src/main/cpp/SDL/src/thread/stdSDL_syscond.cpp
diff --git a/sdl_original/src/thread/stdcpp/SDL_sysmutex.cpp b/app/src/main/cpp/SDL/src/thread/stdSDL_sysmutex.cpp
similarity index 100%
rename from sdl_original/src/thread/stdcpp/SDL_sysmutex.cpp
rename to app/src/main/cpp/SDL/src/thread/stdSDL_sysmutex.cpp
diff --git a/sdl_original/src/thread/stdcpp/SDL_sysmutex_c.h b/app/src/main/cpp/SDL/src/thread/stdSDL_sysmutex_c.h
similarity index 100%
rename from sdl_original/src/thread/stdcpp/SDL_sysmutex_c.h
rename to app/src/main/cpp/SDL/src/thread/stdSDL_sysmutex_c.h
diff --git a/sdl_original/src/thread/stdcpp/SDL_systhread.cpp b/app/src/main/cpp/SDL/src/thread/stdSDL_systhread.cpp
similarity index 100%
rename from sdl_original/src/thread/stdcpp/SDL_systhread.cpp
rename to app/src/main/cpp/SDL/src/thread/stdSDL_systhread.cpp
diff --git a/sdl_original/src/thread/stdcpp/SDL_systhread_c.h b/app/src/main/cpp/SDL/src/thread/stdSDL_systhread_c.h
similarity index 100%
rename from sdl_original/src/thread/stdcpp/SDL_systhread_c.h
rename to app/src/main/cpp/SDL/src/thread/stdSDL_systhread_c.h
diff --git a/sdl_original/src/video/SDL_egl.c b/app/src/main/cpp/SDL/src/video/SDL_egl.c
index a89c0e8..0483004 100644
--- a/sdl_original/src/video/SDL_egl.c
+++ b/app/src/main/cpp/SDL/src/video/SDL_egl.c
@@ -249,6 +249,36 @@ void *SDL_EGL_GetProcAddress(_THIS, const char *proc)
         const Uint32 eglver = (((Uint32)_this->egl_data->egl_version_major) << 16) | ((Uint32)_this->egl_data->egl_version_minor);
         const SDL_bool is_egl_15_or_later = eglver >= ((((Uint32)1) << 16) | 5);
 
+        /* For OSMesa, try OSMesaGetProcAddress first (if available and context is ready)
+         * This ensures we get zink's glGetString instead of system EGL's
+         * IMPORTANT: Only use OSMesaGetProcAddress after OSMesa context is created and made current
+         * Otherwise, the returned function pointers may not work correctly
+         */
+#ifdef __ANDROID__
+        const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+        SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+        if (is_osmesa && _this->egl_data->opengl_dll_handle) {
+            /* Check if OSMesa context is already initialized
+             * We can check this by trying to get OSMesaGetCurrentContext
+             * If it returns non-NULL, the context is ready
+             */
+            void* (*OSMesaGetCurrentContext)(void) = (void* (*)(void))
+                SDL_LoadFunction(_this->egl_data->opengl_dll_handle, "OSMesaGetCurrentContext");
+            if (OSMesaGetCurrentContext && OSMesaGetCurrentContext() != NULL) {
+                /* OSMesa context is ready, use OSMesaGetProcAddress */
+                void* (*OSMesaGetProcAddress)(const char*) = (void* (*)(const char*))
+                    SDL_LoadFunction(_this->egl_data->opengl_dll_handle, "OSMesaGetProcAddress");
+                if (OSMesaGetProcAddress) {
+                    retval = OSMesaGetProcAddress(proc);
+                    if (retval) {
+                        SDL_Log("SDL_EGL: Using OSMesaGetProcAddress for %s (context ready)", proc);
+                    }
+                }
+            }
+            /* If OSMesa context is not ready yet, fall through to EGL methods */
+        }
+#endif
+
         /* EGL 1.5 can use eglGetProcAddress() for any symbol. 1.4 and earlier can't use it for core entry points. */
         if (!retval && is_egl_15_or_later && _this->egl_data->eglGetProcAddress) {
             retval = _this->egl_data->eglGetProcAddress(proc);
@@ -776,29 +806,34 @@ static int SDL_EGL_PrivateChooseConfig(_THIS, SDL_bool set_config_caveat_none)
         attribs[i++] = EGL_PBUFFER_BIT;
     }
 
-    attribs[i++] = EGL_RENDERABLE_TYPE;
-    if (_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES) {
-#ifdef EGL_KHR_create_context
-        if (_this->gl_config.major_version >= 3 &&
-            SDL_EGL_HasExtension(_this, SDL_EGL_DISPLAY_EXTENSION, "EGL_KHR_create_context")) {
-            attribs[i++] = EGL_OPENGL_ES3_BIT_KHR;
-        } else
-#endif
-            if (_this->gl_config.major_version >= 2) {
-            attribs[i++] = EGL_OPENGL_ES2_BIT;
-        } else {
-            attribs[i++] = EGL_OPENGL_ES_BIT;
-        }
-        _this->egl_data->eglBindAPI(EGL_OPENGL_ES_API);
-    } else {
-        attribs[i++] = EGL_OPENGL_BIT;
-        _this->egl_data->eglBindAPI(EGL_OPENGL_API);
-    }
-
-    if (_this->egl_data->egl_surfacetype) {
-        attribs[i++] = EGL_SURFACE_TYPE;
-        attribs[i++] = _this->egl_data->egl_surfacetype;
-    }
+//    /* Skip EGL_RENDERABLE_TYPE for OSMesa/Zink compatibility (similar to gl4es fix)
+//    * Set SDL_EGL_SKIP_RENDERABLE_TYPE=1 to skip this attribute */
+//    const char* skip_renderable_type = SDL_getenv("SDL_EGL_SKIP_RENDERABLE_TYPE");
+//    if (!skip_renderable_type || SDL_strcmp(skip_renderable_type, "1") != 0) {
+//        attribs[i++] = EGL_RENDERABLE_TYPE;
+//        if (_this->gl_config.profile_mask == SDL_GL_CONTEXT_PROFILE_ES) {
+//#ifdef EGL_KHR_create_context
+//            if (_this->gl_config.major_version >= 3 &&
+//                SDL_EGL_HasExtension(_this, SDL_EGL_DISPLAY_EXTENSION, "EGL_KHR_create_context")) {
+//                attribs[i++] = EGL_OPENGL_ES3_BIT_KHR;
+//            } else
+//#endif
+//            if (_this->gl_config.major_version >= 2) {
+//                attribs[i++] = EGL_OPENGL_ES2_BIT;
+//            } else {
+//                attribs[i++] = EGL_OPENGL_ES_BIT;
+//            }
+//            _this->egl_data->eglBindAPI(EGL_OPENGL_ES_API);
+//        } else {
+//            attribs[i++] = EGL_OPENGL_BIT;
+//            _this->egl_data->eglBindAPI(EGL_OPENGL_API);
+//        }
+//    }
+//
+//    if (_this->egl_data->egl_surfacetype) {
+//        attribs[i++] = EGL_SURFACE_TYPE;
+//        attribs[i++] = _this->egl_data->egl_surfacetype;
+//    }
 
     attribs[i++] = EGL_NONE;
 
@@ -973,6 +1008,63 @@ SDL_GLContext SDL_EGL_CreateContext(_THIS, EGLSurface egl_surface)
 #endif
 
     /* Set the context version and other attributes. */
+#ifdef __ANDROID__
+    /* Special handling for gl4es/zink on Android:
+     * - gl4es needs GLES context (translates desktop GL to ES)
+     * - Native zink needs GLES context (on Android without OSMesa)
+     * - OSMesa zink provides true desktop GL and needs desktop GL context
+     */
+    const char *fna3d_driver_attr = SDL_getenv("FNA3D_OPENGL_DRIVER");
+    const char *gl_driver = SDL_getenv("SDL_VIDEO_GL_DRIVER");
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+
+    /* Detect OSMesa (library path contains "OSMesa" or "osmesa") */
+    SDL_bool is_osmesa = (gl_driver && SDL_strcasestr(gl_driver, "osmesa")) ||
+                         (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    SDL_bool is_gl4es = (fna3d_driver_attr && SDL_strcasecmp(fna3d_driver_attr, "gl4es") == 0);
+    SDL_bool is_zink = (fna3d_driver_attr &&
+                        (SDL_strcasecmp(fna3d_driver_attr, "zink") == 0 ||
+                         SDL_strcasecmp(fna3d_driver_attr, "zink25") == 0));
+
+    /* Only gl4es and native zink (without OSMesa) need GLES context */
+    if (is_gl4es || (is_zink && !is_osmesa)) {
+        /* Use GLES context attributes */
+        int gles_version = 3;
+
+        /* Check LIBGL_ES env var to override gl4es backend version */
+        if (is_gl4es) {
+            const char *libgl_es = SDL_getenv("LIBGL_ES");
+            if (libgl_es && SDL_strcmp(libgl_es, "2") == 0) {
+                gles_version = 2;
+                SDL_Log("SDL_EGL: LIBGL_ES=2 detected, using GLES 2.0 backend for gl4es");
+            }
+        }
+
+        attribs[attr++] = EGL_CONTEXT_CLIENT_VERSION;
+        attribs[attr++] = gles_version;
+
+        SDL_Log("SDL_EGL: Creating GLES %d context for %s (using ES API)",
+                gles_version, fna3d_driver_attr);
+    } else if (is_osmesa && is_zink) {
+        /* OSMesa zink: On Android, we still need to use ES API for context creation
+         * OSMesa will handle desktop OpenGL calls internally, even with an ES context
+         * This is because Android EGL only supports EGL_OPENGL_ES_API */
+#ifdef __ANDROID__
+        /* On Android, use ES context (OSMesa handles desktop GL internally) */
+        int gles_version = 3;  /* Use GLES 3.0 for OSMesa zink on Android */
+        SDL_Log("SDL_EGL: OSMesa zink detected on Android, using ES context (OSMesa handles desktop GL internally)");
+        attribs[attr++] = EGL_CONTEXT_CLIENT_VERSION;
+        attribs[attr++] = gles_version;
+        SDL_Log("SDL_EGL: Creating GLES %d context for OSMesa zink (using ES API)", gles_version);
+        /* Continue with ES context creation */
+#else
+        /* On non-Android platforms, use desktop GL context */
+        SDL_Log("SDL_EGL: OSMesa zink detected, using desktop GL context (not forcing GLES)");
+        /* Fall through to normal desktop GL context creation below */
+#endif
+    } else
+#endif
     if ((major_version < 3 || (minor_version == 0 && profile_es)) &&
         _this->gl_config.flags == 0 &&
         (profile_mask == 0 || profile_es)) {
@@ -1028,12 +1120,71 @@ SDL_GLContext SDL_EGL_CreateContext(_THIS, EGLSurface egl_surface)
     attribs[attr++] = EGL_NONE;
 
     /* Bind the API */
+#ifdef __ANDROID__
+    /* API binding strategy on Android:
+     * - Android EGL only supports EGL_OPENGL_ES_API, not EGL_OPENGL_API
+     * - Even with OSMesa zink, we must use EGL_OPENGL_ES_API to create the context
+     * - OSMesa will handle desktop OpenGL calls internally, even with an ES context
+     * - gl4es: Use EGL_OPENGL_ES_API (translates desktop GL to ES)
+     * - zink (with or without OSMesa): Use EGL_OPENGL_ES_API (OSMesa handles desktop GL internally)
+     */
+    const char *fna3d_driver = SDL_getenv("FNA3D_OPENGL_DRIVER");
+    const char *gl_driver_bind = SDL_getenv("SDL_VIDEO_GL_DRIVER");
+    const char *fna3d_gl_lib_bind = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    int force_es_api = 0;
+
+    /* Detect OSMesa */
+    SDL_bool is_osmesa_bind = (gl_driver_bind && SDL_strcasestr(gl_driver_bind, "osmesa")) ||
+                              (fna3d_gl_lib_bind && SDL_strcasestr(fna3d_gl_lib_bind, "osmesa"));
+
+    /* On Android, always use EGL_OPENGL_ES_API (even for OSMesa zink) */
+    if (fna3d_driver) {
+        if (SDL_strcasecmp(fna3d_driver, "gl4es") == 0) {
+            force_es_api = 1;
+            SDL_Log("SDL_EGL: gl4es detected, using EGL_OPENGL_ES_API");
+        } else if ((SDL_strcasecmp(fna3d_driver, "zink") == 0 ||
+                    SDL_strcasecmp(fna3d_driver, "zink25") == 0)) {
+            /* On Android, always use ES API (OSMesa handles desktop GL internally) */
+            force_es_api = 1;
+            if (is_osmesa_bind) {
+                SDL_Log("SDL_EGL: OSMesa zink detected, using EGL_OPENGL_ES_API (OSMesa handles desktop GL internally)");
+            } else {
+                SDL_Log("SDL_EGL: Native zink detected, using EGL_OPENGL_ES_API");
+            }
+        }
+    }
+
+    if (profile_es || force_es_api) {
+        _this->egl_data->apitype = EGL_OPENGL_ES_API;
+    } else {
+        _this->egl_data->apitype = EGL_OPENGL_API;
+    }
+
+    SDL_Log("SDL_EGL: Attempting to bind API: %s (profile_mask=%d, major=%d, minor=%d, force_es_api=%d)",
+            _this->egl_data->apitype == EGL_OPENGL_ES_API ? "EGL_OPENGL_ES_API" : "EGL_OPENGL_API",
+            _this->gl_config.profile_mask,
+            _this->gl_config.major_version,
+            _this->gl_config.minor_version,
+            force_es_api);
+#else
     if (profile_es) {
         _this->egl_data->apitype = EGL_OPENGL_ES_API;
     } else {
         _this->egl_data->apitype = EGL_OPENGL_API;
     }
-    _this->egl_data->eglBindAPI(_this->egl_data->apitype);
+#endif
+
+    if (_this->egl_data->eglBindAPI(_this->egl_data->apitype) == EGL_FALSE) {
+        EGLint error = _this->egl_data->eglGetError();
+#ifdef __ANDROID__
+        SDL_Log("SDL_EGL: eglBindAPI failed with error 0x%x", error);
+        if (!profile_es && !force_es_api) {
+            SDL_Log("SDL_EGL: Desktop OpenGL API not supported on Android");
+        }
+#endif
+        SDL_EGL_SetError("Could not bind EGL API", "eglBindAPI");
+        return NULL;
+    }
 
     egl_context = _this->egl_data->eglCreateContext(_this->egl_data->egl_display,
                                                     _this->egl_data->egl_config,
diff --git a/sdl_original/src/video/android/SDL_androidgl.c b/app/src/main/cpp/SDL/src/video/android/SDL_androidgl.c
index 5e5ef60..b53c149 100644
--- a/sdl_original/src/video/android/SDL_androidgl.c
+++ b/app/src/main/cpp/SDL/src/video/android/SDL_androidgl.c
@@ -22,6 +22,8 @@
 
 #if defined(SDL_VIDEO_DRIVER_ANDROID) && defined(SDL_VIDEO_OPENGL_EGL)
 
+#include <unistd.h> // for usleep
+
 /* Android SDL video driver implementation */
 
 #include "SDL_video.h"
@@ -33,12 +35,117 @@
 #include "../../core/android/SDL_android.h"
 
 #include <android/log.h>
+#include <android/native_window.h>
 
 #include <dlfcn.h>
+#include <stdlib.h>
+#include <string.h>
+#include "../../SDL_internal.h"  // SDL_bool is defined here
+#include "SDL_androidwindow.h"  // For SDL_WindowData
 
 int Android_GLES_MakeCurrent(_THIS, SDL_Window *window, SDL_GLContext context)
 {
     if (window && context) {
+        /* For OSMesa zink, create OSMesa context when SDL context is made current
+         * This ensures OSMesa context is ready before FNA3D calls glGetString()
+         */
+#ifdef __ANDROID__
+        const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+        SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "MakeCurrent: FNA3D_OPENGL_LIBRARY=%s, is_osmesa=%d",
+            fna3d_gl_lib ? fna3d_gl_lib : "(null)", is_osmesa);
+
+        if (is_osmesa) {
+            /* Try to load osm_renderer_init from the main library using dlopen/dlsym
+             * Try multiple possible library names
+             */
+            static bool osm_initialized = false;
+            if (!osm_initialized) {
+                const char* lib_names[] = {"libralaunch.so", "libmain.so", NULL};
+                void *main_lib = NULL;
+                int i = 0;
+
+                while (lib_names[i] != NULL && main_lib == NULL) {
+                    main_lib = dlopen(lib_names[i], RTLD_LAZY | RTLD_LOCAL);
+                    if (main_lib) {
+                        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                            "?Loaded library: %s", lib_names[i]);
+                    } else {
+                        __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                            "?Failed to load %s: %s", lib_names[i], dlerror());
+                    }
+                    i++;
+                }
+
+                if (main_lib) {
+                    typedef bool (*osm_renderer_init_func)(ANativeWindow*);
+                    typedef bool (*osm_renderer_is_available_func)(void);
+                    typedef bool (*osm_renderer_is_initialized_func)(void);
+
+                    osm_renderer_is_available_func osm_is_available = (osm_renderer_is_available_func)
+                        dlsym(main_lib, "osm_renderer_is_available");
+                    osm_renderer_is_initialized_func osm_is_initialized = (osm_renderer_is_initialized_func)
+                        dlsym(main_lib, "osm_renderer_is_initialized");
+                    osm_renderer_init_func osm_init = (osm_renderer_init_func)
+                        dlsym(main_lib, "osm_renderer_init");
+
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "OSMesa function pointers: is_available=%p, is_initialized=%p, init=%p",
+                        osm_is_available, osm_is_initialized, osm_init);
+
+                    if (osm_is_available && osm_is_initialized && osm_init) {
+                        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                            "All OSMesa functions loaded successfully");
+
+                        if (osm_is_available() && !osm_is_initialized()) {
+                            SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+                            ANativeWindow *native_window = data->native_window;
+
+                            if (native_window != NULL) {
+                                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                    "Creating OSMesa context when SDL context is made current...");
+                                if (osm_init(native_window)) {
+                                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                        "?OSMesa context created and made current");
+
+                                    // CRITICAL: Wait a bit for OSMesa context to be fully ready
+                                    // This ensures glGetString() will work when FNA3D initializes
+                                    // zink needs time to initialize the Vulkan device and OpenGL context
+                                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                        "Waiting for OSMesa context to be fully ready...");
+                                    usleep(150000); // 150ms delay for zink initialization
+
+                                    osm_initialized = true;
+                                } else {
+                                    __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                                        "?Failed to create OSMesa context, will use EGL fallback");
+                                }
+                            } else {
+                                __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                                    "?Native window is NULL, cannot create OSMesa context");
+                            }
+                        } else if (osm_is_initialized()) {
+                            osm_initialized = true;
+                        }
+                    } else {
+                        __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                            "?Failed to load OSMesa functions from library");
+                    }
+                    // Don't close main_lib, we need the symbols to remain available
+                } else {
+                    __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                        "?Failed to load any OSMesa-compatible library");
+                }
+            }
+
+            /* For OSMesa, don't call SDL_EGL_MakeCurrent - OSMesa manages its own context */
+            __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                "OSMesa mode: returning success without EGL MakeCurrent");
+            return 0;
+        }
+#endif
         return SDL_EGL_MakeCurrent(_this, ((SDL_WindowData *)window->driverdata)->egl_surface, context);
     } else {
         return SDL_EGL_MakeCurrent(_this, NULL, NULL);
@@ -51,6 +158,23 @@ SDL_GLContext Android_GLES_CreateContext(_THIS, SDL_Window *window)
 
     Android_ActivityMutex_Lock_Running();
 
+#ifdef __ANDROID__
+    /* For OSMesa, return a dummy context since OSMesa manages its own OpenGL context */
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "OSMesa detected, returning dummy GL context (OSMesa manages its own context)");
+        /* Return a non-NULL dummy pointer to indicate success
+         * OSMesa context is managed separately via osm_init_context()
+         * We use (void*)1 as a sentinel value to indicate "OSMesa mode"
+         */
+        SDL_UnlockMutex(Android_ActivityMutex);
+        return (SDL_GLContext)(void*)1;
+    }
+#endif
+
     ret = SDL_EGL_CreateContext(_this, ((SDL_WindowData *)window->driverdata)->egl_surface);
 
     SDL_UnlockMutex(Android_ActivityMutex);
@@ -64,6 +188,41 @@ int Android_GLES_SwapWindow(_THIS, SDL_Window *window)
 
     SDL_LockMutex(Android_ActivityMutex);
 
+#ifdef __ANDROID__
+    /* For OSMesa/zink rendering, use OSMesa swap buffers instead of EGL
+     * OSMesa renders to a software buffer that needs to be copied to the native window
+     */
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        /* Try to call osm_swap_buffers from the main library */
+        static void (*osm_swap_buffers_fn)(void) = NULL;
+        static SDL_bool osm_swap_init_attempted = SDL_FALSE;
+
+        if (!osm_swap_init_attempted) {
+            osm_swap_init_attempted = SDL_TRUE;
+            void* main_lib = dlopen("libmain.so", RTLD_LAZY | RTLD_LOCAL);
+            if (main_lib) {
+                osm_swap_buffers_fn = (void (*)(void)) dlsym(main_lib, "osm_swap_buffers");
+                if (osm_swap_buffers_fn) {
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "?Found osm_swap_buffers function for OSMesa rendering");
+                }
+            }
+        }
+
+        if (osm_swap_buffers_fn) {
+            osm_swap_buffers_fn();
+            SDL_UnlockMutex(Android_ActivityMutex);
+            return 0;
+        } else {
+            __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                "?osm_swap_buffers not found, falling back to EGL swap");
+        }
+    }
+#endif
+
     /* The following two calls existed in the original Java code
      * If you happen to have a device that's affected by their removal,
      * please report to our bug tracker. -- Gabriel
@@ -77,12 +236,257 @@ int Android_GLES_SwapWindow(_THIS, SDL_Window *window)
 
     return retval;
 }
-
 int Android_GLES_LoadLibrary(_THIS, const char *path)
 {
+    const char* custom_egl_path = NULL;
+    const char* current_renderer = NULL;
+    const char* egl_lib_path = NULL;
+
+    __android_log_print(ANDROID_LOG_INFO, "Android_GLES", "Android_GLES_LoadLibrary called, path=%s", path ? path : "(null)");
+
+    /*  Android_LoadRenderer() ?+     * ?SDL_EGL_LoadLibrary 
+     */
+    #ifdef SDL_VIDEO_DRIVER_ANDROID
+    extern const char* Android_GetCurrentRenderer(void);
+    extern const char* Android_GetCurrentRendererLibPath(void);
+
+    current_renderer = Android_GetCurrentRenderer();
+    egl_lib_path = Android_GetCurrentRendererLibPath();
+
+    __android_log_print(ANDROID_LOG_INFO, "Android_GLES", "current_renderer = %s, egl_lib_path = %s",
+                        current_renderer ? current_renderer : "(null)",
+                        egl_lib_path ? egl_lib_path : "(null)");
+
+    if (current_renderer && SDL_strcmp(current_renderer, "native") != 0 && SDL_strcmp(current_renderer, "none") != 0) {
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "Renderer '%s' already preloaded", current_renderer);
+
+        /*  OSMesa zink/virgl 
+         * OSMesa ?OSMesa ?+         * gl4es  EGL + ?GL ?+         */
+        const char* fna3d_ogl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+        SDL_bool is_osmesa = (fna3d_ogl_lib && SDL_strcasestr(fna3d_ogl_lib, "osmesa"));
+
+        //  zink ?+        const char *fna3d_driver = SDL_getenv("FNA3D_OPENGL_DRIVER");
+        SDL_bool is_zink = (current_renderer && (SDL_strcmp(current_renderer, "zink") == 0 ||
+                                                 SDL_strstr(current_renderer, "vulkan_zink") != NULL)) ||
+                           (fna3d_driver && SDL_strcasecmp(fna3d_driver, "zink") == 0);
+
+        if (is_zink) {
+            __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "Zink renderer detected, checking Vulkan availability...");
+
+            /* ?VULKAN_PTR  Java  */
+            const char* vulkan_ptr = SDL_getenv("VULKAN_PTR");
+            if (vulkan_ptr != NULL && vulkan_ptr[0] != '\0') {
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                            "?Vulkan library already loaded (VULKAN_PTR=%s)", vulkan_ptr);
+            } else {
+                /*  Java ?*/
+                __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                            "?VULKAN_PTR not set, attempting to load Vulkan...");
+                void* vulkan_handle = dlopen("libvulkan.so", RTLD_LAZY | RTLD_LOCAL);
+                if (vulkan_handle != NULL) {
+                    char envval[64];
+                    SDL_snprintf(envval, sizeof(envval), "%p", vulkan_handle);
+                    SDL_setenv("VULKAN_PTR", envval, 1);
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                                "?Vulkan library loaded: %s", envval);
+                } else {
+                    __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                                "?Failed to load Vulkan library: %s", dlerror());
+                }
+            }
+        }
+
+        /*  OSMesa ?OSMesa  SDL_EGL_LoadLibrary
+         * OSMesa  EGL?GL 
+         */
+        if (is_osmesa && fna3d_ogl_lib) {
+            __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "OSMesa renderer: Using OSMesa library: %s", fna3d_ogl_lib);
+            return SDL_EGL_LoadLibrary(_this, fna3d_ogl_lib, (NativeDisplayType)0, 0);
+        }
+
+        /* ?OSMesa gl4es ?EGL
+         * GL  eglGetProcAddress ?dlsym ?GL ?+         */
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "Non-OSMesa renderer '%s': Using system EGL with preloaded GL library",
+                    current_renderer);
+        return SDL_EGL_LoadLibrary(_this, egl_lib_path, (NativeDisplayType)0, 0);
+    }
+    #endif
+
+    /*  FNA3D_OPENGL_LIBRARY  EGL ?+     * ?Android ?+     */
+    custom_egl_path = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+
+    if (custom_egl_path != NULL && custom_egl_path[0] != '\0') {
+        SDL_LogInfo(SDL_LOG_CATEGORY_VIDEO,
+                    "Android_GLES_LoadLibrary: Using custom EGL from FNA3D_OPENGL_LIBRARY: %s",
+                    custom_egl_path);
+        return SDL_EGL_LoadLibrary(_this, custom_egl_path, (NativeDisplayType)0, 0);
+    }
+
+    /* ? libEGL.so) */
     return SDL_EGL_LoadLibrary(_this, path, (NativeDisplayType)0, 0);
 }
 
+void *Android_GLES_GetProcAddress(_THIS, const char *proc)
+{
+#ifdef __ANDROID__
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    /* For OSMesa, use OSMesaGetProcAddress */
+    if (is_osmesa) {
+        static void* (*OSMesaGetProcAddress_fn)(const char*) = NULL;
+        static SDL_bool osmesa_proc_init_attempted = SDL_FALSE;
+        static int log_count = 0;
+
+        if (!osmesa_proc_init_attempted) {
+            osmesa_proc_init_attempted = SDL_TRUE;
+            void* osmesa_lib = dlopen(fna3d_gl_lib, RTLD_LAZY | RTLD_LOCAL);
+            if (osmesa_lib) {
+                OSMesaGetProcAddress_fn = (void* (*)(const char*)) dlsym(osmesa_lib, "OSMesaGetProcAddress");
+                if (OSMesaGetProcAddress_fn) {
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "?OSMesaGetProcAddress loaded for GL function lookup from %s", fna3d_gl_lib);
+                } else {
+                    __android_log_print(ANDROID_LOG_ERROR, "Android_GLES",
+                        "?OSMesaGetProcAddress NOT found in %s", fna3d_gl_lib);
+                }
+            } else {
+                __android_log_print(ANDROID_LOG_ERROR, "Android_GLES",
+                    "?Failed to dlopen OSMesa library: %s - %s", fna3d_gl_lib, dlerror());
+            }
+        }
+
+        if (OSMesaGetProcAddress_fn) {
+            void* result = OSMesaGetProcAddress_fn(proc);
+            if (log_count < 20) {
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "GetProcAddress(%s) -> OSMesa: %p", proc, result);
+                log_count++;
+            }
+            if (result) {
+                return result;
+            }
+            __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                "OSMesaGetProcAddress returned NULL for %s, falling back to EGL", proc);
+        }
+    }
+
+    /* For custom GL libraries (gl4es, etc.), try dlsym first
+     * These libraries provide their own GL implementations
+     */
+    if (fna3d_gl_lib && !is_osmesa) {
+        static void* custom_gl_lib = NULL;
+        static SDL_bool custom_gl_init_attempted = SDL_FALSE;
+        static int custom_log_count = 0;
+
+        if (!custom_gl_init_attempted) {
+            custom_gl_init_attempted = SDL_TRUE;
+            /* Open with RTLD_NOLOAD to get the already-loaded library handle */
+            custom_gl_lib = dlopen(fna3d_gl_lib, RTLD_LAZY | RTLD_NOLOAD);
+            if (!custom_gl_lib) {
+                /* Try opening it normally */
+                custom_gl_lib = dlopen(fna3d_gl_lib, RTLD_LAZY | RTLD_LOCAL);
+            }
+            if (custom_gl_lib) {
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "?Custom GL library loaded for function lookup: %s", fna3d_gl_lib);
+            } else {
+                __android_log_print(ANDROID_LOG_WARN, "Android_GLES",
+                    "?Failed to load custom GL library: %s - %s", fna3d_gl_lib, dlerror());
+            }
+        }
+
+        if (custom_gl_lib) {
+            void* result = dlsym(custom_gl_lib, proc);
+            if (result) {
+                if (custom_log_count < 20) {
+                    __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                        "GetProcAddress(%s) -> Custom GL: %p", proc, result);
+                    custom_log_count++;
+                }
+                return result;
+            }
+            /* Fall through to EGL if custom library doesn't have the function */
+        }
+    }
+#endif
+    return SDL_EGL_GetProcAddress(_this, proc);
+}
+
+void Android_GLES_UnloadLibrary(_THIS)
+{
+    SDL_EGL_UnloadLibrary(_this);
+}
+
+int Android_GLES_SetSwapInterval(_THIS, int interval)
+{
+    return SDL_EGL_SetSwapInterval(_this, interval);
+}
+
+int Android_GLES_GetSwapInterval(_THIS)
+{
+    return SDL_EGL_GetSwapInterval(_this);
+}
+
+void Android_GLES_DeleteContext(_THIS, SDL_GLContext context)
+{
+#ifdef __ANDROID__
+    /* For OSMesa, the context is a dummy pointer - don't call EGL delete */
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "OSMesa mode: skipping EGL DeleteContext (OSMesa manages its own context)");
+        return;
+    }
+#endif
+    SDL_EGL_DeleteContext(_this, context);
+}
+
+void Android_GLES_GetDrawableSize(_THIS, SDL_Window *window, int *w, int *h)
+{
+#ifdef __ANDROID__
+    const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+    SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+    if (is_osmesa) {
+        /* For OSMesa, get the drawable size from the native window */
+        SDL_WindowData *data = (SDL_WindowData *)window->driverdata;
+        if (data && data->native_window) {
+            int native_w = ANativeWindow_getWidth(data->native_window);
+            int native_h = ANativeWindow_getHeight(data->native_window);
+            if (native_w > 0 && native_h > 0) {
+                if (w) *w = native_w;
+                if (h) *h = native_h;
+                __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+                    "OSMesa GetDrawableSize: %dx%d (from ANativeWindow)", native_w, native_h);
+                return;
+            }
+        }
+        /* Fall back to window size */
+        if (w) *w = window->w;
+        if (h) *h = window->h;
+        __android_log_print(ANDROID_LOG_INFO, "Android_GLES",
+            "OSMesa GetDrawableSize: %dx%d (fallback to window size)", window->w, window->h);
+        return;
+    }
+#endif
+    /* Default: use window size in pixels */
+    SDL_GetWindowSizeInPixels(window, w, h);
+}
+
 #endif /* SDL_VIDEO_DRIVER_ANDROID */
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/sdl_original/src/video/android/SDL_androidgl.h b/app/src/main/cpp/SDL/src/video/android/SDL_androidgl.h
index 4fb505c..e0fbf35 100644
--- a/sdl_original/src/video/android/SDL_androidgl.h
+++ b/app/src/main/cpp/SDL/src/video/android/SDL_androidgl.h
@@ -23,10 +23,16 @@
 #ifndef SDL_androidgl_h_
 #define SDL_androidgl_h_
 
+int Android_GLES_LoadLibrary(_THIS, const char *path);
+void *Android_GLES_GetProcAddress(_THIS, const char *proc);
+void Android_GLES_UnloadLibrary(_THIS);
 SDL_GLContext Android_GLES_CreateContext(_THIS, SDL_Window *window);
 int Android_GLES_MakeCurrent(_THIS, SDL_Window *window, SDL_GLContext context);
+int Android_GLES_SetSwapInterval(_THIS, int interval);
+int Android_GLES_GetSwapInterval(_THIS);
 int Android_GLES_SwapWindow(_THIS, SDL_Window *window);
-int Android_GLES_LoadLibrary(_THIS, const char *path);
+void Android_GLES_DeleteContext(_THIS, SDL_GLContext context);
+void Android_GLES_GetDrawableSize(_THIS, SDL_Window *window, int *w, int *h);
 
 #endif /* SDL_androidgl_h_ */
 
diff --git a/sdl_original/src/video/android/SDL_androidmouse.c b/app/src/main/cpp/SDL/src/video/android/SDL_androidmouse.c
index 29ee05e..82bf251 100644
--- a/sdl_original/src/video/android/SDL_androidmouse.c
+++ b/app/src/main/cpp/SDL/src/video/android/SDL_androidmouse.c
@@ -251,6 +251,67 @@ void Android_OnMouse(SDL_Window *window, int state, int action, float x, float y
     }
 }
 
+/* Mouse events without state tracking - for direct control */
+void Android_OnMouseDirect(SDL_Window *window, int state, int action, float x, float y, SDL_bool relative)
+{
+    Uint8 button;
+
+    if (!window) {
+        return;
+    }
+
+    switch (action) {
+    case ACTION_DOWN:
+        button = TranslateButton(state);
+        SDL_SendMouseMotion(window, 0, relative, (int)x, (int)y);
+        SDL_SendMouseButton(window, 0, SDL_PRESSED, button);
+        break;
+
+    case ACTION_UP:
+        button = TranslateButton(state);
+        SDL_SendMouseMotion(window, 0, relative, (int)x, (int)y);
+        SDL_SendMouseButton(window, 0, SDL_RELEASED, button);
+        break;
+
+    case ACTION_MOVE:
+    case ACTION_HOVER_MOVE:
+        SDL_SendMouseMotion(window, 0, relative, (int)x, (int)y);
+        break;
+
+    case ACTION_SCROLL:
+        SDL_SendMouseWheel(window, 0, x, y, SDL_MOUSEWHEEL_NORMAL);
+        break;
+
+    default:
+        break;
+    }
+}
+
+/* Direct mouse button send - bypasses last_state tracking for virtual controls */
+void Android_OnMouseButtonDirect(SDL_Window *window, int sdlButton, int pressed, float x, float y)
+{
+    if (!window) {
+        return;
+    }
+
+    /* First move to position */
+    SDL_SendMouseMotion(window, 0, SDL_FALSE, (int)x, (int)y);
+
+    /* Then send button event directly */
+    SDL_SendMouseButton(window, 0, pressed ? SDL_PRESSED : SDL_RELEASED, (Uint8)sdlButton);
+}
+
+/* Send mouse button without moving cursor - for virtual button controls */
+void Android_OnMouseButtonOnly(SDL_Window *window, int sdlButton, int pressed)
+{
+    if (!window) {
+        return;
+    }
+
+    /* Send button event only, don't move mouse cursor */
+    SDL_SendMouseButton(window, 0, pressed ? SDL_PRESSED : SDL_RELEASED, (Uint8)sdlButton);
+}
+
 #endif /* SDL_VIDEO_DRIVER_ANDROID */
 
 /* vi: set ts=4 sw=4 expandtab: */
diff --git a/sdl_original/src/video/android/SDL_androidmouse.h b/app/src/main/cpp/SDL/src/video/android/SDL_androidmouse.h
index 6ff7249..636441b 100644
--- a/sdl_original/src/video/android/SDL_androidmouse.h
+++ b/app/src/main/cpp/SDL/src/video/android/SDL_androidmouse.h
@@ -26,6 +26,9 @@
 
 extern void Android_InitMouse(void);
 extern void Android_OnMouse(SDL_Window *window, int button, int action, float x, float y, SDL_bool relative);
+extern void Android_OnMouseDirect(SDL_Window *window, int button, int action, float x, float y, SDL_bool relative);
+extern void Android_OnMouseButtonDirect(SDL_Window *window, int sdlButton, int pressed, float x, float y);
+extern void Android_OnMouseButtonOnly(SDL_Window *window, int sdlButton, int pressed);
 extern void Android_QuitMouse(void);
 
 #endif /* SDL_androidmouse_h_ */
diff --git a/app/src/main/cpp/SDL/src/video/android/SDL_androidrenderer.c b/app/src/main/cpp/SDL/src/video/android/SDL_androidrenderer.c
new file mode 100644
index 0000000..933fce1
--- /dev/null
+++ b/app/src/main/cpp/SDL/src/video/android/SDL_androidrenderer.c
@@ -0,0 +1,340 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+*/
+
+/**
+ * SDL Android Dynamic Renderer Loader
+ *
+ * ?+ * 1.  RALCORE_RENDERER ?+ * 2.  RALCORE_EGL ?ANGLE ?+ * 3.  dlopen(RTLD_GLOBAL) ?+ * 4.  LD_PRELOAD ?+ */
+
+#include "../../SDL_internal.h"
+
+#if SDL_VIDEO_DRIVER_ANDROID
+
+#include "SDL_androidrenderer.h"
+#include "SDL_androidgl.h"
+#include "SDL_hints.h"
+
+#include "../SDL_egl_c.h"
+
+#include <dlfcn.h>
+#include <stdlib.h>
+#include <android/log.h>
+
+#define LOG_TAG "SDL_Renderer"
+#define LOGI(...) __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)
+#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)
+
+/*  */
+static const SDL_RendererBackend RENDERER_BACKENDS[] = {
+    /*  EGL/GLES () */
+    {
+        .name = "native",
+        .egl_library = NULL,
+        .gles_library = NULL,
+        .need_preload = SDL_FALSE
+    },
+
+    /* gl4es (OpenGL 2.1 ?GLES 2.0) */
+    {
+        .name = "gl4es",
+        .egl_library = "libEGL_gl4es.so",
+        .gles_library = "libGL_gl4es.so",
+        .need_preload = SDL_TRUE
+    },
+
+    /* ANGLE (OpenGL ES over Vulkan) */
+    {
+        .name = "angle",
+        .egl_library = "libEGL_angle.so",
+        .gles_library = "libGLESv2_angle.so",
+        .need_preload = SDL_TRUE
+    },
+
+    /* MobileGlues */
+    {
+        .name = "mobileglues",
+        .egl_library = "libmobileglues.so",
+        .gles_library = "libmobileglues.so",
+        .need_preload = SDL_TRUE
+    },
+
+    /* Zink (OpenGL over Vulkan via OSMesa) */
+    {
+        .name = "zink",
+        .egl_library = "libOSMesa.so",
+        .gles_library = "libOSMesa.so",
+        .need_preload = SDL_TRUE
+    },
+
+    /* DXVK (D3D11 over Vulkan) - FNA3D  D3D11  + DXVK */
+    {
+        .name = "dxvk",
+        .egl_library = NULL,  /* DXVK ?EGL?SDL hint */
+        .gles_library = NULL, /* DXVK ?GLES */
+        .need_preload = SDL_TRUE  /* ?SDL hint */
+    },
+
+    /*  */
+    {NULL, NULL, NULL, SDL_FALSE}
+};
+
+/*  */
+static const SDL_RendererBackend *current_renderer = NULL;
+static void *renderer_handle = NULL;  /* dlopen ?*/
+
+/**
+ * ?+ */
+static const SDL_RendererBackend* FindRendererBackend(const char *name)
+{
+    if (!name || name[0] == '\0') {
+        return &RENDERER_BACKENDS[0];  /*  native */
+    }
+
+    for (int i = 0; RENDERER_BACKENDS[i].name != NULL; i++) {
+        if (SDL_strcasecmp(RENDERER_BACKENDS[i].name, name) == 0) {
+            return &RENDERER_BACKENDS[i];
+        }
+    }
+
+    LOGE("Unknown renderer '%s', falling back to native", name);
+    return &RENDERER_BACKENDS[0];
+}
+
+/**
+ * 
+ */
+static const char* GetRendererFromEnv(void)
+{
+    const char *ralcore_renderer = SDL_getenv("RALCORE_RENDERER");
+    const char *ralcore_egl = SDL_getenv("RALCORE_EGL");
+
+    if (ralcore_renderer != NULL) {
+        /*  RALCORE_RENDERER ?*/
+        if (SDL_strcmp(ralcore_renderer, "gl4es") == 0) {
+            return "gl4es";
+        } else if (SDL_strcmp(ralcore_renderer, "vulkan_zink") == 0) {
+            return "zink";
+        } else if (SDL_strcmp(ralcore_renderer, "gallium_virgl") == 0) {
+            return "virgl";
+        } else if (SDL_strcmp(ralcore_renderer, "gallium_freedreno") == 0) {
+            return "freedreno";
+        } else if (SDL_strcmp(ralcore_renderer, "dxvk") == 0) {
+            return "dxvk";
+        }
+    }
+
+    if (ralcore_egl != NULL && SDL_strstr(ralcore_egl, "angle") != NULL) {
+        return "angle";
+    }
+
+    return NULL; /*  native ?*/
+}
+
+/**
+ * 
+ */
+SDL_bool Android_LoadRenderer(const char *renderer_name)
+{
+    const SDL_RendererBackend *backend;
+    const char *env_renderer;
+
+    LOGI("================================================================");
+    LOGI("  SDL Dynamic Renderer Loading");
+    LOGI("  Requested: %s", renderer_name ? renderer_name : "(null)");
+
+    /*  */
+    env_renderer = GetRendererFromEnv();
+    if (env_renderer != NULL) {
+        LOGI("  Environment: RALCORE_RENDERER/RALCORE_EGL -> %s", env_renderer);
+        renderer_name = env_renderer;
+    }
+
+    LOGI("================================================================");
+
+    /* ?*/
+    backend = FindRendererBackend(renderer_name);
+    if (!backend) {
+        LOGE("Failed to find renderer backend");
+        return SDL_FALSE;
+    }
+
+    LOGI("  Selected: %s", backend->name);
+
+    /*  */
+    if (!backend->need_preload) {
+        LOGI("  Using system libEGL.so and libGLESv2.so");
+        current_renderer = backend;
+        return SDL_TRUE;
+    }
+
+    /* DXVK  SDL hint ?FNA3D  D3D11  */
+    if (SDL_strcasecmp(backend->name, "dxvk") == 0) {
+        LOGI("  DXVK renderer: Setting FNA3D_FORCE_DRIVER=D3D11");
+        SDL_SetHint("FNA3D_FORCE_DRIVER", "D3D11");
+        /* DXVK WSI  SDL2 */
+        setenv("DXVK_WSI_DRIVER", "SDL2", 1);
+        LOGI("  ?DXVK_WSI_DRIVER = SDL2");
+        /*  EGL/GLES  DXVK  OpenGL  */
+        LOGI("  Using system libEGL.so (DXVK uses Vulkan directly via FNA3D D3D11 driver)");
+        current_renderer = backend;
+        return SDL_TRUE;
+    }
+
+    /*  */
+    if (!backend->egl_library) {
+        LOGE("  Renderer %s has no EGL library specified", backend->name);
+        return SDL_FALSE;
+    }
+
+    LOGI("  EGL Library: %s", backend->egl_library);
+    if (backend->gles_library && SDL_strcmp(backend->egl_library, backend->gles_library) != 0) {
+        LOGI("  GLES Library: %s", backend->gles_library);
+    }
+
+    /*  dlopen  (RTLD_GLOBAL ?) */
+    LOGI("  Loading with dlopen(RTLD_NOW | RTLD_GLOBAL)...");
+
+    /* ?LD_LIBRARY_PATH  */
+    renderer_handle = dlopen(backend->egl_library, RTLD_NOW | RTLD_GLOBAL);
+    
+    /*  runtime_libs  */
+    if (!renderer_handle) {
+        const char *runtime_dir = getenv("RALCORE_RUNTIMEDIR");
+        if (runtime_dir) {
+            char full_path[512];
+            SDL_snprintf(full_path, sizeof(full_path), "%s/%s", runtime_dir, backend->egl_library);
+            LOGI("  Trying runtime_libs path: %s", full_path);
+            renderer_handle = dlopen(full_path, RTLD_NOW | RTLD_GLOBAL);
+        }
+    }
+    
+    /*  native lib  */
+    if (!renderer_handle) {
+        const char *native_dir = getenv("RALCORE_NATIVEDIR");
+        if (native_dir) {
+            char full_path[512];
+            SDL_snprintf(full_path, sizeof(full_path), "%s/%s", native_dir, backend->egl_library);
+            LOGI("  Trying native lib path: %s", full_path);
+            renderer_handle = dlopen(full_path, RTLD_NOW | RTLD_GLOBAL);
+        }
+    }
+    
+    if (!renderer_handle) {
+        LOGE("  ?dlopen failed: %s", dlerror());
+        LOGE("  Falling back to native renderer");
+        current_renderer = &RENDERER_BACKENDS[0];
+        return SDL_FALSE;
+    }
+
+    LOGI("  ?dlopen success, handle = %p", renderer_handle);
+
+    /*  LD_PRELOAD  */
+    /* etenv ?SDL  */
+    /*  SDL  Java ?*/
+    if (setenv("LD_PRELOAD", backend->egl_library, 1) == 0) {
+        LOGI("  ?LD_PRELOAD = %s", backend->egl_library);
+    } else {
+        LOGI("  ?LD_PRELOAD already set or cannot be set");
+    }
+
+    /*  FNA3D_OPENGL_DRIVER ?FNA3D ?*/
+    if (backend->name && SDL_strcmp(backend->name, "native") != 0) {
+
+        /*  SDL_VIDEO_GL_DRIVER ?+    *  SDL ?dlopen ?*/
+        setenv("SDL_VIDEO_GL_DRIVER", backend->egl_library, 1);
+        LOGI("  ?SDL_VIDEO_GL_DRIVER = %s", backend->egl_library);
+
+        setenv("FNA3D_OPENGL_DRIVER", backend->name, 1);
+        LOGI("  ?FNA3D_OPENGL_DRIVER = %s", backend->name);
+
+
+    }
+
+    /*  gl4es */
+    /* ?setenv(..., 0)  */
+    /*  Box64Launcher ?RendererConfig ?*/
+    if (SDL_strcasecmp(backend->name, "gl4es") == 0) {
+        const char *existing_libgl_es = SDL_getenv("LIBGL_ES");
+        if (existing_libgl_es) {
+            LOGI("  LIBGL_ES already set to '%s', not overriding", existing_libgl_es);
+        } else {
+            setenv("LIBGL_ES", "3", 1);         /*  GLES 3.0 (?dotnet ? */
+        }
+        setenv("LIBGL_MIPMAP", "3", 0);     /*  mipmap (? */
+        setenv("LIBGL_NPOT", "1", 0);       /* ?2 ?(? */
+        setenv("LIBGL_SHRINKPOP", "0", 0);  /*  (? */
+        LOGI("  ?gl4es environment configured (LIBGL_ES=%s)",
+             SDL_getenv("LIBGL_ES") ? SDL_getenv("LIBGL_ES") : "not set");
+    }
+
+    current_renderer = backend;
+    LOGI(" Renderer '%s' loaded successfully", backend->name);
+    LOGI("================================================================");
+
+    return SDL_TRUE;
+}
+
+/**
+ *  GL 
+ *
+ * gl4es: ?Android_GL4ES_*  AGL ?+ * ?  EGL 
+ */
+/* Forward declaration for OSMesa drawable size */
+extern void Android_GLES_GetDrawableSize(SDL_VideoDevice *_this, SDL_Window *window, int *w, int *h);
+
+SDL_bool Android_SetupGLFunctions(SDL_VideoDevice *device)
+{
+    const char *renderer_name;
+
+    if (!device) {
+        return SDL_FALSE;
+    }
+
+    renderer_name = current_renderer ? current_renderer->name : "native";
+    LOGI("Setting up GL functions for renderer: %s", renderer_name);
+
+
+
+    device->GL_LoadLibrary = Android_GLES_LoadLibrary;
+    device->GL_GetProcAddress = Android_GLES_GetProcAddress;
+    device->GL_UnloadLibrary = Android_GLES_UnloadLibrary;
+    device->GL_CreateContext = Android_GLES_CreateContext;
+    device->GL_MakeCurrent = Android_GLES_MakeCurrent;
+    device->GL_SetSwapInterval = Android_GLES_SetSwapInterval;
+    device->GL_GetSwapInterval = Android_GLES_GetSwapInterval;
+    device->GL_SwapWindow = Android_GLES_SwapWindow;
+    device->GL_DeleteContext = Android_GLES_DeleteContext;
+    device->GL_GetDrawableSize = Android_GLES_GetDrawableSize; /* CRITICAL for OSMesa */
+
+    LOGI("?GL functions configured");
+
+    return SDL_TRUE;
+}
+
+/**
+ * ?+ */
+const char* Android_GetCurrentRenderer(void)
+{
+    return current_renderer ? current_renderer->name : "none";
+}
+
+/**
+ * EGL?+ */
+const char* Android_GetCurrentRendererLibPath(void)
+{
+    return current_renderer ? current_renderer->egl_library : NULL;
+}
+
+#endif /* SDL_VIDEO_DRIVER_ANDROID */
diff --git a/app/src/main/cpp/SDL/src/video/android/SDL_androidrenderer.h b/app/src/main/cpp/SDL/src/video/android/SDL_androidrenderer.h
new file mode 100644
index 0000000..2f4ec39
--- /dev/null
+++ b/app/src/main/cpp/SDL/src/video/android/SDL_androidrenderer.h
@@ -0,0 +1,77 @@
+/*
+  Simple DirectMedia Layer
+  Copyright (C) 1997-2024 Sam Lantinga <slouken@libsdl.org>
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+*/
+
+/**
+ * @file SDL_androidrenderer.h
+ *
+ * Android Dynamic Renderer Loading
+
+ * 
+ */
+
+#ifndef SDL_androidrenderer_h_
+#define SDL_androidrenderer_h_
+
+#include "../../SDL_internal.h"
+#include "../SDL_sysvideo.h"
+
+/**
+ * ?+ */
+typedef struct {
+    const char *name;           /* ?(native, gl4es, angle, etc.) */
+    const char *egl_library;    /* EGL ?(NULL = ) */
+    const char *gles_library;   /* GLES ?(NULL = ) */
+    SDL_bool need_preload;      /*  LD_PRELOAD  */
+} SDL_RendererBackend;
+
+/**
+ * 
+ *
+ *  dlopen + LD_PRELOAD ?+ *
+ * @param renderer_name ?(?SDL_RENDERER ?FNA3D_OPENGL_DRIVER )
+ * @return SDL_TRUE , SDL_FALSE 
+ */
+extern SDL_bool Android_LoadRenderer(const char *renderer_name);
+
+/**
+ *  OpenGL ?video device
+ *
+ * ?GL 
+ *  LD_PRELOAD?EGL ?SDL_EGL 
+ *
+ * @param device SDL video device
+ * @return SDL_TRUE , SDL_FALSE 
+ */
+extern SDL_bool Android_SetupGLFunctions(SDL_VideoDevice *device);
+
+/**
+ * 
+ */
+extern const char* Android_GetCurrentRenderer(void);
+
+/**
+ * EGL?+ */
+extern const char* Android_GetCurrentRendererLibPath(void);
+
+#endif /* SDL_androidrenderer_h_ */
diff --git a/sdl_original/src/video/android/SDL_androidtouch.c b/app/src/main/cpp/SDL/src/video/android/SDL_androidtouch.c
index c44f2b0..af99e10 100644
--- a/sdl_original/src/video/android/SDL_androidtouch.c
+++ b/app/src/main/cpp/SDL/src/video/android/SDL_androidtouch.c
@@ -64,9 +64,21 @@ void Android_OnTouch(SDL_Window *window, int touch_device_id_in, int pointer_fin
     }
 
     fingerId = (SDL_FingerID)pointer_finger_id_in;
+    
+    /* Reduced logging - only log touch down/up, not every move event */
+    #if 0
+    __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouch", 
+        "Android_OnTouch: action=%d finger=%d pos=(%.2f,%.2f)",
+        action, pointer_finger_id_in, x, y);
+    #endif
+    
     switch (action) {
     case ACTION_DOWN:
     case ACTION_POINTER_DOWN:
+        #if 0
+        __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouch", 
+            "  -> SendTouch DOWN finger=%d", pointer_finger_id_in);
+        #endif
         SDL_SendTouch(touchDeviceId, fingerId, window, SDL_TRUE, x, y, p);
         break;
 
@@ -76,6 +88,10 @@ void Android_OnTouch(SDL_Window *window, int touch_device_id_in, int pointer_fin
 
     case ACTION_UP:
     case ACTION_POINTER_UP:
+        #if 0
+        __android_log_print(ANDROID_LOG_VERBOSE, "SDLTouch", 
+            "  -> SendTouch UP finger=%d", pointer_finger_id_in);
+        #endif
         SDL_SendTouch(touchDeviceId, fingerId, window, SDL_FALSE, x, y, p);
         break;
 
diff --git a/sdl_original/src/video/android/SDL_androidvideo.c b/app/src/main/cpp/SDL/src/video/android/SDL_androidvideo.c
index f54b4c3..b8fa8cd 100644
--- a/sdl_original/src/video/android/SDL_androidvideo.c
+++ b/app/src/main/cpp/SDL/src/video/android/SDL_androidvideo.c
@@ -34,6 +34,7 @@
 
 #include "SDL_androidvideo.h"
 #include "SDL_androidgl.h"
+
 #include "SDL_androidclipboard.h"
 #include "SDL_androidevents.h"
 #include "SDL_androidkeyboard.h"
@@ -42,6 +43,8 @@
 #include "SDL_androidwindow.h"
 #include "SDL_androidvulkan.h"
 #include "SDL_androidmessagebox.h"
+#include "SDL_androidrenderer.h"  /* Dynamic renderer loading */
+
 
 #define ANDROID_VID_DRIVER_NAME "Android"
 
@@ -120,23 +123,64 @@ static SDL_VideoDevice *Android_CreateDevice(void)
     device->SetWindowFullscreen = Android_SetWindowFullscreen;
     device->MinimizeWindow = Android_MinimizeWindow;
     device->SetWindowResizable = Android_SetWindowResizable;
+    device->SetWindowSize = Android_SetWindowSize;
+    device->SetWindowPosition = Android_SetWindowPosition;
     device->DestroyWindow = Android_DestroyWindow;
     device->GetWindowWMInfo = Android_GetWindowWMInfo;
 
     device->free = Android_DeleteDevice;
 
-    /* GL pointers */
-#ifdef SDL_VIDEO_OPENGL_EGL
-    device->GL_LoadLibrary = Android_GLES_LoadLibrary;
-    device->GL_GetProcAddress = Android_GLES_GetProcAddress;
-    device->GL_UnloadLibrary = Android_GLES_UnloadLibrary;
-    device->GL_CreateContext = Android_GLES_CreateContext;
-    device->GL_MakeCurrent = Android_GLES_MakeCurrent;
-    device->GL_SetSwapInterval = Android_GLES_SetSwapInterval;
-    device->GL_GetSwapInterval = Android_GLES_GetSwapInterval;
-    device->GL_SwapWindow = Android_GLES_SwapWindow;
-    device->GL_DeleteContext = Android_GLES_DeleteContext;
-#endif
+    /* ================================================================
+     *  Dynamic Renderer Loading
+     * ================================================================
+     *
+     * 
+     *
+     * ?+     *   SDL_RENDERER ?FNA3D_OPENGL_DRIVER
+     *     - native:  (libEGL.so + libGLESv2.so)
+     *     - gl4es: OpenGL 2.1 ?+     *     - angle: OpenGL ES over Vulkan
+     *     - zink: OpenGL over Vulkan
+     *
+     * ?+     *   1.  dlopen(RTLD_GLOBAL) ?+     *   2.  LD_PRELOAD  SDL ?dlopen("libEGL.so")
+     *   3. ?EGL 
+     *   4. SDL  Android_GLES_* 
+     */
+
+    /*  */
+    {
+        const char* renderer_name = SDL_getenv("SDL_RENDERER");
+    if (!renderer_name || renderer_name[0] == '\0') {
+        renderer_name = SDL_getenv("FNA3D_OPENGL_DRIVER");
+    }
+    if (!renderer_name || renderer_name[0] == '\0') {
+        renderer_name = "native";  /* ?*/
+    }
+
+    /*  */
+    if (!Android_LoadRenderer(renderer_name)) {
+        SDL_LogWarn(SDL_LOG_CATEGORY_VIDEO,
+                    "Failed to load renderer '%s', falling back to native",
+                    renderer_name);
+        Android_LoadRenderer("native");
+    }
+
+    /*  GL  */
+    /*  LD_PRELOAD?EGL  */
+    if (!Android_SetupGLFunctions(device)) {
+        SDL_LogError(SDL_LOG_CATEGORY_VIDEO, "Failed to setup GL functions");
+        SDL_free(data);
+        SDL_free(device);
+        return NULL;
+    }
+
+    SDL_LogInfo(SDL_LOG_CATEGORY_VIDEO,
+                "?Renderer initialized: %s",
+                Android_GetCurrentRenderer());
+    }
 
 #ifdef SDL_VIDEO_VULKAN
     device->Vulkan_LoadLibrary = Android_Vulkan_LoadLibrary;
@@ -197,6 +241,54 @@ int Android_VideoInit(_THIS)
 
     SDL_AddDisplayMode(&_this->displays[0], &mode);
 
+    // Lets add more display modes!
+    int alt_heights[] = {480, 600, 720, 768, 800, 960, 1024, 1080, 1152, 1280, 1440, 1536, 1600,
+                         1792, 1920};
+    int num_of_alts = sizeof(alt_heights) / sizeof(alt_heights[0]);
+    // Well we don't care about the order as SDL automatically sort them
+    for (int i = 0; i < num_of_alts; i++) {
+        if (alt_heights[i] < Android_DeviceHeight) {
+            int alt_width = (alt_heights[i] * Android_DeviceWidth) / Android_DeviceHeight;
+
+            SDL_DisplayMode alt_mode;
+            alt_mode.format = Android_ScreenFormat;
+            alt_mode.w = alt_width;
+            alt_mode.h = alt_heights[i];
+            alt_mode.refresh_rate = Android_ScreenRate;
+            alt_mode.driverdata = NULL;
+            SDL_AddDisplayMode(&_this->displays[0], &alt_mode);
+        }
+    }
+    // not yet implemented, because need to implement black borders on two sides, and fix touching
+//    // 4:3 aspect ratios
+//    for (int i = 0; i < num_of_alts; i++) {
+//        if (alt_heights[i] <= Android_DeviceHeight) {
+//            int alt_width = (alt_heights[i] * 4) / 3;
+//
+//            SDL_DisplayMode alt_mode;
+//            alt_mode.format = Android_ScreenFormat;
+//            alt_mode.w = alt_width;
+//            alt_mode.h = alt_heights[i];
+//            alt_mode.refresh_rate = Android_ScreenRate;
+//            alt_mode.driverdata = NULL;
+//            SDL_AddDisplayMode(&_this->displays[0], &alt_mode);
+//        }
+//    }
+//    // 16:9 aspect ratios
+//    for (int i = 0; i < num_of_alts; i++) {
+//        if (alt_heights[i] <= Android_DeviceHeight) {
+//            int alt_width = (alt_heights[i] * 16) / 9;
+//
+//            SDL_DisplayMode alt_mode;
+//            alt_mode.format = Android_ScreenFormat;
+//            alt_mode.w = alt_width;
+//            alt_mode.h = alt_heights[i];
+//            alt_mode.refresh_rate = Android_ScreenRate;
+//            alt_mode.driverdata = NULL;
+//            SDL_AddDisplayMode(&_this->displays[0], &alt_mode);
+//        }
+//    }
+
     Android_InitTouch();
 
     Android_InitMouse();
diff --git a/sdl_original/src/video/android/SDL_androidwindow.c b/app/src/main/cpp/SDL/src/video/android/SDL_androidwindow.c
index 2624331..4f43eac 100644
--- a/sdl_original/src/video/android/SDL_androidwindow.c
+++ b/app/src/main/cpp/SDL/src/video/android/SDL_androidwindow.c
@@ -33,6 +33,8 @@
 #include "SDL_androidwindow.h"
 #include "SDL_hints.h"
 
+#include <android/log.h>
+
 /* Currently only one window */
 SDL_Window *Android_Window = NULL;
 
@@ -41,17 +43,23 @@ int Android_CreateWindow(_THIS, SDL_Window *window)
     SDL_WindowData *data;
     int retval = 0;
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", " Android_CreateWindow called, window=%p", window);
+
     Android_ActivityMutex_Lock_Running();
 
     if (Android_Window) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_Window", "?Already have a window!");
         retval = SDL_SetError("Android only supports one window");
         goto endfunction;
     }
 
     /* Set orientation */
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "Setting orientation...");
     Android_JNI_SetOrientation(window->w, window->h, window->flags & SDL_WINDOW_RESIZABLE, SDL_GetHint(SDL_HINT_ORIENTATIONS));
 
     /* Adjust the window data to match the screen */
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "Adjusting window size from %dx%d to %dx%d",
+        window->w, window->h, Android_SurfaceWidth, Android_SurfaceHeight);
     window->x = 0;
     window->y = 0;
     window->w = Android_SurfaceWidth;
@@ -64,42 +72,65 @@ int Android_CreateWindow(_THIS, SDL_Window *window)
     SDL_SetMouseFocus(window);
     SDL_SetKeyboardFocus(window);
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "Allocating window data...");
     data = (SDL_WindowData *)SDL_calloc(1, sizeof(*data));
     if (!data) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_Window", "?Out of memory!");
         retval = SDL_OutOfMemory();
         goto endfunction;
     }
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "Getting native window...");
     data->native_window = Android_JNI_GetNativeWindow();
 
     if (!data->native_window) {
+        __android_log_print(ANDROID_LOG_ERROR, "SDL_Window", "?Could not fetch native window!");
         SDL_free(data);
         retval = SDL_SetError("Could not fetch native window");
         goto endfunction;
     }
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "?Native window obtained: %p", data->native_window);
 
     /* Do not create EGLSurface for Vulkan window since it will then make the window
        incompatible with vkCreateAndroidSurfaceKHR */
+    /* Also skip EGLSurface for OSMesa since OSMesa uses ANativeWindow_lock directly */
 #ifdef SDL_VIDEO_OPENGL_EGL
-    if (window->flags & SDL_WINDOW_OPENGL) {
-        data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType)data->native_window);
-
-        if (data->egl_surface == EGL_NO_SURFACE) {
-            ANativeWindow_release(data->native_window);
-            SDL_free(data);
-            retval = -1;
-            goto endfunction;
+    {
+        const char *fna3d_gl_lib = SDL_getenv("FNA3D_OPENGL_LIBRARY");
+        SDL_bool is_osmesa = (fna3d_gl_lib && SDL_strcasestr(fna3d_gl_lib, "osmesa"));
+
+        if (is_osmesa) {
+            __android_log_print(ANDROID_LOG_INFO, "SDL_Window",
+                "OSMesa detected, skipping EGL surface creation (OSMesa uses ANativeWindow_lock)");
+            data->egl_surface = EGL_NO_SURFACE;
+        } else {
+            __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "SDL_VIDEO_OPENGL_EGL is defined, creating EGL surface...");
+            if (window->flags & SDL_WINDOW_OPENGL) {
+                data->egl_surface = SDL_EGL_CreateSurface(_this, (NativeWindowType)data->native_window);
+
+                if (data->egl_surface == EGL_NO_SURFACE) {
+                    __android_log_print(ANDROID_LOG_ERROR, "SDL_Window", "?Failed to create EGL surface!");
+                    ANativeWindow_release(data->native_window);
+                    SDL_free(data);
+                    retval = -1;
+                    goto endfunction;
+                }
+            }
         }
     }
+#else
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "SDL_VIDEO_OPENGL_EGL is NOT defined, skipping EGL surface creation");
 #endif
 
     window->driverdata = data;
     Android_Window = window;
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "?Android_CreateWindow succeeded!");
 
 endfunction:
 
     SDL_UnlockMutex(Android_ActivityMutex);
 
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "Android_CreateWindow returning %d", retval);
     return retval;
 }
 
@@ -170,6 +201,46 @@ void Android_SetWindowResizable(_THIS, SDL_Window *window, SDL_bool resizable)
     Android_JNI_SetOrientation(window->w, window->h, window->flags & SDL_WINDOW_RESIZABLE, SDL_GetHint(SDL_HINT_ORIENTATIONS));
 }
 
+void Android_SetWindowSize(_THIS, SDL_Window *window)
+{
+    /* Force window to always be fullscreen size - ignore any resize attempts */
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", " Android_SetWindowSize called - forcing fullscreen size");
+
+    SDL_LockMutex(Android_ActivityMutex);
+
+    if (window == Android_Window) {
+        /* Always reset to fullscreen dimensions */
+        window->x = 0;
+        window->y = 0;
+        window->w = Android_SurfaceWidth;
+        window->h = Android_SurfaceHeight;
+
+        __android_log_print(ANDROID_LOG_INFO, "SDL_Window",
+            "?Window forced to fullscreen: %dx%d at (0,0)",
+            Android_SurfaceWidth, Android_SurfaceHeight);
+    }
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
+void Android_SetWindowPosition(_THIS, SDL_Window *window)
+{
+    /* Force window to always be at (0,0) - ignore any position change attempts */
+    __android_log_print(ANDROID_LOG_INFO, "SDL_Window", " Android_SetWindowPosition called - forcing position (0,0)");
+
+    SDL_LockMutex(Android_ActivityMutex);
+
+    if (window == Android_Window) {
+        /* Always reset to origin */
+        window->x = 0;
+        window->y = 0;
+
+        __android_log_print(ANDROID_LOG_INFO, "SDL_Window", "?Window position forced to (0,0)");
+    }
+
+    SDL_UnlockMutex(Android_ActivityMutex);
+}
+
 void Android_DestroyWindow(_THIS, SDL_Window *window)
 {
     SDL_LockMutex(Android_ActivityMutex);
diff --git a/sdl_original/src/video/android/SDL_androidwindow.h b/app/src/main/cpp/SDL/src/video/android/SDL_androidwindow.h
index 240c77c..5d9be1e 100644
--- a/sdl_original/src/video/android/SDL_androidwindow.h
+++ b/app/src/main/cpp/SDL/src/video/android/SDL_androidwindow.h
@@ -31,6 +31,8 @@ extern void Android_SetWindowTitle(_THIS, SDL_Window *window);
 extern void Android_SetWindowFullscreen(_THIS, SDL_Window *window, SDL_VideoDisplay *display, SDL_bool fullscreen);
 extern void Android_MinimizeWindow(_THIS, SDL_Window *window);
 extern void Android_SetWindowResizable(_THIS, SDL_Window *window, SDL_bool resizable);
+extern void Android_SetWindowSize(_THIS, SDL_Window *window);
+extern void Android_SetWindowPosition(_THIS, SDL_Window *window);
 
 extern void Android_DestroyWindow(_THIS, SDL_Window *window);
 extern SDL_bool Android_GetWindowWMInfo(_THIS, SDL_Window *window, struct SDL_SysWMinfo *info);
diff --git a/sdl_original/test/nacl/Makefile b/sdl_original/test/nacl/Makefile
deleted file mode 100644
index 9ca166c..0000000
--- a/sdl_original/test/nacl/Makefile
+++ /dev/null
@@ -1,63 +0,0 @@
-# Copyright (c) 2013 The Chromium Authors. All rights reserved.
-# Use of this source code is governed by a BSD-style license that can be
-# found in the LICENSE file.
-
-# GNU Makefile based on shared rules provided by the Native Client SDK.
-# See README.Makefiles for more details.
-
-VALID_TOOLCHAINS := pnacl
-
-# NACL_SDK_ROOT ?= $(abspath $(CURDIR)/../../..)
-include $(NACL_SDK_ROOT)/tools/common.mk
-
-
-TARGET = sdl_app
-DEPS = ppapi_simple nacl_io
-# ppapi_simple and SDL2 end up being listed twice due to dependency solving issues -- Gabriel
-LIBS = SDL2_test SDL2 ppapi_simple SDL2main SDL2 $(DEPS) ppapi_gles2 ppapi_cpp ppapi pthread 
-
-CFLAGS := -Wall
-SOURCES ?= testgles2.c
-
-# Build rules generated by macros from common.mk:
-# Overriden macro from NACL SDK to be able to customize the library search path -- Gabriel
-# Specific Link Macro 
-#
-# $1 = Target Name
-# $2 = List of inputs
-# $3 = List of libs
-# $4 = List of deps
-# $5 = List of lib dirs
-# $6 = Other Linker Args
-#
-# For debugging, we translate the pre-finalized .bc file.
-#
-define LINKER_RULE
-all: $(1).pexe 
-$(1)_x86_32.nexe : $(1).bc
-	$(call LOG,TRANSLATE,$$@,$(PNACL_TRANSLATE) --allow-llvm-bitcode-input -arch x86-32 $$^ -o $$@)
-
-$(1)_x86_64.nexe : $(1).bc
-	$(call LOG,TRANSLATE,$$@,$(PNACL_TRANSLATE) --allow-llvm-bitcode-input -arch x86-64 $$^ -o $$@)
-
-$(1)_arm.nexe : $(1).bc
-	$(call LOG,TRANSLATE,$$@,$(PNACL_TRANSLATE) --allow-llvm-bitcode-input -arch arm $$^ -o $$@)
-
-$(1).pexe: $(1).bc
-	$(call LOG,FINALIZE,$$@,$(PNACL_FINALIZE) -o $$@ $$^)
-
-$(1).bc: $(2) $(foreach dep,$(4),$(STAMPDIR)/$(dep).stamp)
-	$(call LOG,LINK,$$@,$(PNACL_LINK) -o $$@ $(2) $(PNACL_LDFLAGS) $(foreach path,$(5),-L$(path)/pnacl/$(CONFIG)) -L./lib $(foreach lib,$(3),-l$(lib)) $(6))
-endef
-
-$(foreach dep,$(DEPS),$(eval $(call DEPEND_RULE,$(dep))))
-$(foreach src,$(SOURCES),$(eval $(call COMPILE_RULE,$(src),$(CFLAGS))))
-
-ifeq ($(CONFIG),Release)
-$(eval $(call LINK_RULE,$(TARGET)_unstripped,$(SOURCES),$(LIBS),$(DEPS)))
-$(eval $(call STRIP_RULE,$(TARGET),$(TARGET)_unstripped))
-else
-$(eval $(call LINK_RULE,$(TARGET),$(SOURCES),$(LIBS),$(DEPS)))
-endif
-
-$(eval $(call NMF_RULE,$(TARGET),))
